<!doctype html>
<html>
  <head>
    <title>Git Rebase</title>
    <link rel="stylesheet" href="../../common.css">
  </head>
  <body>
    <h1>Git Rebase</h1>
	
	<h2>Prerequisite</h2>
<div class="code"><code><pre>git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"</pre></code></div>
Set Notepad++ as the Git editor instead of Vim. See <a href="https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/How-to-set-Notepad-as-the-default-Git-editor-for-commits-instead-of-Vim">here</a>

	<h2>Update the Main Branch</h2>
<div class="code"><code><pre>git switch main
git pull
git switch feature
</pre></code></div>
Update the main branch with the latest changes, and then switch back to the feature branch.

	<h2>Squash Commits on a Feature Branch (optional)</h2>
This part is <i>optional</i>, it is only needed if there are many commits in the feature branch. Rebasing the feature branch onto the main branch when it contains a single commit, you will need to resolve <b>conflicts only once</b> (the same file will not come up as a conflict more than once).<br>
<br>
Using <i>git push -f</i> can be useful after rebasing, squashing, and resetting. Always use this command with caution, as it can overwrite the remote repository's history, potentially leading to data loss.<br>


	<h2>Rebase onto the main branch</h2>
<div class="code"><code><pre>git switch feature       # Switch to the feature branch
git rebase main          # Start the rebase onto the main branch
# resolve any conflicts that arise
git add .                # Stage the resolved files
git rebase --continue    # Continue the rebase process
git push -f              # Force push the changes to the remote feature branch
</pre></code></div>
	<h2>Best Practices</h2>
To keep the feature branch updated with the main branch (to avoid diverging too much from the main branch), rebase the feature branch onto the main branch (instead of merging) after pulling changes from the main branch. This is because the incoming commits from the main branch would mix them with your commits, interrupting the linear history.
	
	<h2>Learn Git Branching</h2>
	<center><img src="images/git_rebase1.png" width="100%" height="100%"/></center>
	<br>
	<center><img src="images/git_rebase2.png" width="100%" height="100%"/></center>

    <h2>GitLab Merge Requests</h2>
	<b><a href="https://docs.gitlab.com/ee/user/project/merge_requests/methods/">Merge method</a> settings</b><br>
	Determine what happens to the commit history when you merge a merge request.<br>
	<b>- Merge commit</b><br>
	Every merge creates a merge commit.<br>
	<b>- Merge commit with semi-linear history</b><br>
	Every merge creates a merge commit.<br>
	Merging is only allowed when the source branch is up-to-date with its target.<br>
	When semi-linear merge is not possible, the user is given the option to rebase.<br>
	<b>- Fast-forward merge</b> (*)<br>
	No merge commits are created.<br>
	Fast-forward merges only.<br>
	When there is a merge conflict, the user is given the option to rebase.<br>
	If merge trains are enabled, merging is only possible if the branch can be rebased withoutÂ conflicts.	
	
    <h2>References</h2>	
    <ul>
      <li><a href="https://cbea.ms/git-commit/">How to Write a Git Commit Message</a></li>
      <li><a href="https://learngitbranching.js.org/">Learn Git Branching</a></li>
    </ul>
  </body>
</html>
