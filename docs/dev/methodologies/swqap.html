<!doctype html>
<html>
  <head>
    <title>SWQAP</title>
    <link rel="stylesheet" href="../../common.css">
  </head>
  <body>
    <h1>SWQAP (Software Quality Assurance Plan)</h1>
	<h2>Created</h2>
	<p>Date: 6/30/2023</p>
	<p>Name: Attila Balint</p>

    <h2>1 Introduction</h2>
    <h3>1.1 Purpose</h3>	
	<p>The purpose of this document is to describe the quality assurance activities and procedures that will be performed for a software project. This document helps to ensure that the software products or services meet the expected quality standards and requirements, and that the software development process is consistent and repeatable. This document also helps to communicate the quality objectives and expectations to the software project team, the software provider, and the software customers or users.</p>	
    
    <h3>1.2 Scope</h3>
	<p>The scope of this document is to define the boundaries and limitations of the quality assurance activities and procedures that will be performed for a software project. The scope may include:</p>
	<ul>
	<li>The software products or services that are subject to quality assurance</li>
	<li>The software development phases or stages that are covered by quality assurance</li>
	<li>The software development methodologies or approaches that are used for quality assurance</li>
	<li>The software development tools or technologies that are used for quality assurance</li>
	<li>The software project team members or roles that are involved in quality assurance</li>
	<li>The software project stakeholders or parties that are affected by quality assurance</li>
    <li>The software project assumptions or constraints that are relevant to quality assurance</li>		
	</ul>	
	
	<h3>1.3 Objectives</h3>
	<p>The objectives of this document are to:</p>
	<ul>
	<li>Define the quality standards and models that will be followed and applied in the software project</li>
	<li>Describe the quality assurance activities and procedures that will be performed throughout the software development life cycle</li>
	<li>Identify the quality assurance deliverables and documents that will be produced and maintained in the software project</li>
	<li>Assess the quality risks and issues that may affect the software project</li>
	<li>Provide a quality assurance schedule that outlines the time frames and milestones for each quality assurance activity and procedure</li>
	<li>Provide a list of references and appendices that support this document</li>
	</ul>

    <h3>1.4 Validity</h3>
	<p>The validity of this document is the period of time during which this document is applicable and effective for a software project. The validity may depend on:
	<ul>
	<li>The software project duration or schedule</li>
	<li>The software project changes or revisions</li>
	<li>The software project completion or termination</li>
	<li>The software project review or approval</li>
	</ul>
	<p>The validity should be clearly stated in this document, along with the conditions or criteria for updating or revising this document in case of any changes or deviations in the software project.</p>
    
	<h3>1.5 Update Scheme</h3>
	<p>The update scheme of this document is the process and procedure for modifying or amending this document in case of any changes or deviations in the software project. The update scheme may include:
	<ul>
	<li>The triggers or events that require an update or revision of the SWQAP document</li>
	<li>The roles or responsibilities of the software project team members or stakeholders for initiating, reviewing, approving, and implementing the update or revision of the SWQAP document</li>
	<li>The tools or techniques for tracking, recording, and communicating the update or revision of the SWQAP document</li>
	<li>The frequency or intervals for updating or revising the SWQAP document</li>
	<li>The version control or configuration management of the SWQAP document</li>
	</ul>
	<p>The update scheme should be clearly stated in this document, along with the guidelines or standards for ensuring the consistency and accuracy.</p>

    <h2>2 Referenced Documents</h2>
	<p></p>
	
    <h2>3 Definitions</h2>	
    <h3>3.1 Terms</h3>
	<p>Docker: ToDo</p>
    <h3>3.2 Abbreviations</h3>
	<p>SIT: System Integration Testing</p>		
	
    <h2>4 Software Development Processes</h2>	
    <h3>4.1 Version Control System</h3>
	<p>Git as a version control system is a software tool that helps to track and manage changes to the software code, documents, and other artifacts in a software project. It helps to ensure the quality, consistency, and reliability of the software products or services, by enabling different types of testing, reviewing, and deploying on different versions or branches of the software code. It also helps to communicate the changes, updates, and statuses of the software code to the software project team, the software provider, and the software customers or users.</p>
	
    <h3>4.2 Branching Strategy</h3>
	<p>A branching strategy is a set of rules and guidelines that define how branches are created, named, managed, merged, deleted, and documented in a software project. A branching strategy helps to organize and coordinate the work of multiple developers or teams on a shared codebase, using a version control system. It also helps to ensure the quality, stability, and security of the software product or service, by enabling different types of testing, reviewing, and deploying on different branches.</p>
	<p>Elements of the branching strategy are:</p>
	<ul>
	<li>Branching model is Git/GitLab Flow.</li>
	<li>Branch naming conventions are features/feature-name for feature branching, bugfixes/description for bug and hot fixes, users/username/description for developer specific branches.</li>
	<li>Branch merging rule is merge requests/pull requests with code reviews and approvals.</li>
	<li>Branch lifecycle management practices are creating branches from the master branch, updating branches regularly with the latest changes from the master branch, deleting branches after merging them to the master branch, keeping branches short-lived and focused on a single feature or bug fix.</li>
	</ul>    
	
	<h3>4.3 Version Tagging</h3>
	<p>Version Tagging is a process of labeling or marking a specific version of the software code, documents, and other artifacts in a software project as stable, reliable, and ready for production. It helps to identify and access the stable versions easily and quickly, without having to remember the exact revision number or date. It also helps to communicate the release status and history of the software products or services to the software project team, the software provider, and the software customers or users.</p>
	<p>Semantic Versioning:</p>
	<ul>
	<li>A version number is MAJOR.MINOR.PATCH</li>
	<li>The MAJOR part is incremented when there are incompatible or breaking changes in the software code, such as changing the interface or removing a feature</li>
	<li>The MINOR part is incremented when there are new features or enhancements in the software code that are backward compatible, such as adding a new function or improving performance</li>
	<li>The PATCH part is incremented when there are bug fixes or corrections in the software code that are backward compatible, such as fixing an error or resolving an issue</li>	
	<li>Examples: v1.2.1, v2.0.0-beta.1, v2.0.0-rc.1</li>	
	</ul> 	
	<p>If the project is still in the initial development phase, meaning that it has a rapidly changing and unstable code, then the first tag version number should be 0.1.0. This indicates that any subsequent changes may not be backward compatible. The MAJOR part should remain at 0 until the project reaches a stable state and becomes 1.0.0.</p>
	
	<h3>4.4 Code Review Process</h3>
	<p>Code Review Process is a process of systematically examining and evaluating the software code, documents, and other artifacts in a software project by one or more peers before they are merged and shipped. It helps to ensure or improve the quality, consistency, and reliability of the software products or services, by identifying and fixing bugs, errors, vulnerabilities, or other issues. It also helps to share knowledge, skills, and best practices among the software project team members and stakeholders.</p>	
	
    <h3>4.5 Testing Process</h3>
	<p>ToDo</p>	
	
    <h3>4.6 Integration Process</h3>
	<p>ToDO</p>	
	
    <h3>4.7 Deployment Process</h3>
	<p>we must have a separate SIT environment for testing which is managed solely by IP. The DEV environment would stay under SW control.
The SIT environment would be built of docker containers orchestrated by docker compose. These containers’ images would be built now on developer machines and later in Gitlab CI/CD, the SIT environment itself would not be used for source code compilation and build (like the DEV now).</p>

	<p>To achieve the mentioned goals the application containers’ parameterization should be externalized and able to set according to the target environment by docker compose or Kubernetes/Helm.
Now the parameters are included in the built application package (kind of hardwired), which must be changed within a short timeframe to make SIT deployment feasible.</p>

	<p>The SIT deployment job is assigned to Attila. To not compromise the roadmap and delivery of SW team by this high impact change, Attila could participate in its development as contributor and submit the changes via MRs reviewed by SW colleagues. This way these technical changes can be developed and tested apart from the business-related developments.</p>

	<p>Development must be completely stopped on DEV and the following version tracking rules will be introduced:<br>
1. You need a DevTest branch, only this version can be installed on the DEV environment.<br>
2. The branch you want to test on DEV must be merged (PR) into the DevTest branch.<br>
3. The DevTest branch version that has been installed must be tagged with the date of installation and the name of the installing user, the ticket numbers must also be included in the commit (in any case).<br>
4. The version handed over for testing from the DevTest branch must be merged (released, PR) into the master and divided (you have to figure out how, but I would be happy with a version number as well)<br>
5. Installs on Attila SIT with a specific tag (version number) from the master.</p>

	<p>In the future, if we do not receive a master version that can be installed on the SIT without errors, I cannot accept it as fulfillment. This is not equivalent to the fact that there are no bugs, but it means that the system can be reproduced from source code and parameter files on any docker container-based environment and starts without errors, including pulling up the persistence environment from scratch (aka database scripts).</p>			

    <h2>4 Tools</h2>	
	<p>ToDO</p>	

    <h2>4 Roles</h2>	
	<p>ToDO</p>	
	
	<h2>4 Responsibilities</h2>	
	<p>ToDO</p>	
	
	<h2>4 Deliverables</h2>	
	<p>ToDO</p>		
	
	<h2>4 Risks</h2>	
	<p>ToDO</p>	
	
	<h2>4 Metrics</h2>	
	<p>ToDO</p>	
	

	
  </body>
</html>

