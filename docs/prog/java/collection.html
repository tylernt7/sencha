<!doctype html>
<html>
  <head>
    <title>Collection API</title>
    <link rel="stylesheet" href="../../common.css">	
  </head>
  <body>
    <h1>Collection API</h1>
	<p>A <i>collection</i> represents a group of objects. A <i>collections framework</i> is a unified architecture for representing and manipulating collections.</p>
    <h2>Collection Hierarchy</h2>
	<p><img src="images\collection_classes.png" width="100%" height="100%"/></p>
	
	<h2>Synchronization Wrappers</h2>
	<p><img src="images\synch_wrappers.png" width="50%" height="50%"/></p>
	<p>Synchronized collections lock the whole collection while concurrent collections lock only the relevant segments of the object (ConcurrentHashMap) or copy the whole object and swap with a newer one (CopyOnWriteArrayList).</p>
	<p><i>public static &lt;T&gt; List&lt;T&gt; Collections.singletonList(T o)</i>: Returns an immutable (megv√°ltoztathatatlan) list containing only the specified object. This list will always contain only one element. When we try to add/remove an element on the returned singleton list, it will give UnsupportedOperationException.</p>
	
	<h2>Concurrent Collections</h2>	
	<p><img src="images\concurrent_collection.png" width="55%" height="55%"/>
	<img src="images\concurrent_map.png" width="44%" height="44%"/></p>	
	<p><img src="images\concurrent_queue.png" width="100%" height="100%"/></p>

	<h2>Comparison</h2>
		
	<table border="1">
	<thead>
	  <tr>
		<th></th>
		<th>Implementation</th>
		<th>Order</th>
		<th>Time cost</th>
		<th>Iterator</th>
		<th>Null value</th>
	  </tr>
	</thead>
	<tbody>	
	  <tr>
		<td><b>Vector</b></td>
		<td>Resizable array</td>
		<td>Insertion order</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
	  </tr>		
	  <tr>
		<td><b>ArrayList</b></td>
		<td>Resizable array</td>
		<td>Insertion order</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
	  </tr>
	  <tr>
		<td><b>LinkedList</b></td>
		<td>Doubly-linked list</td>
		<td>Insertion order</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
	  </tr>	  
	  <tr>
		<td><b>CopyOnWriteArrayList</b></td>
		<td>Resizable array</td>
		<td>Insertion order</td>
		<td>n</td>
		<td>Snapshot</td>
		<td>Yes</td>
	  </tr>	  	  

      <tr><td>.</td></tr>

	  <tr>
		<td><b>HashSet</b></td>
		<td>Hash table</td>
		<td>No</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
	  </tr>			  
	  <tr>
		<td><b>LinkedHashSet</b></td>
		<td>Hash table and linked list</td>
		<td>Insertion order</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
	  </tr>		
	  <tr>
		<td><b>TreeSet</b></td>
		<td>Red-Black tree</td>
		<td>Natural ordering of its elements</td>
		<td>log(n)</td>
		<td>Fail-fast</td>
		<td>No</td>
	  </tr>			  
	  <tr>
		<td><b>CopyOnWriteArraySet</b></td>
		<td>Set</td>
		<td>No</td>
		<td>n</td>
		<td>Snapshot</td>
		<td>Yes</td>
	  </tr>
	  <tr>
		<td><b>ConcurrentSkipListSet</b></td>
		<td>Skip list</td>
		<td>Natural ordering of its elements</td>
		<td>log(n)</td>
		<td>Weakly consistent</td>
		<td>No</td>
	  </tr>		  
	
	  <tr><td>.</td></tr>
	
	  <tr>
		<td><b>LinkedBlockingQueue</b></td>
		<td>Linked nodes</td>
		<td>FIFO</td>
		<td>1</td>
		<td>Weakly consistent</td>
		<td>No</td>
	  </tr> 	  	
	  <tr>
		<td><b>ConcurrentLinkedQueue</b></td>
		<td>Linked nodes</td>
		<td>FIFO</td>
		<td>1</td>
		<td>Weakly consistent</td>
		<td>No</td>
	  </tr>	
	  <tr>
		<td><b>ArrayBlockingQueue</b></td>
		<td>Array</td>
		<td>FIFO</td>
		<td>1</td>
		<td>Weakly consistent</td>
		<td>No</td>
	  </tr>	
	  <tr>
		<td><b>SynchronousQueue</b></td>
		<td>Rendezvous channel</td>
		<td>FIFO</td>
		<td>1</td>
		<td>Weakly consistent</td>
		<td>No</td>
	  </tr>	
	  <tr>
		<td><b>LinkedBlockingDeque</b></td>
		<td>Linked nodes</td>
		<td>FIFO and LIFO</td>
		<td>1</td>
		<td>Weakly consistent</td>
		<td>No</td>
	  </tr>		  
	</tbody>
	</table>	

	<table border="1">
	<thead>
	  <tr>
		<th></th>
		<th width="166">Implementation</th>
		<th width="205">Order</th>
		<th>Time cost</th>
		<th>Iterator</th>
		<th>Null key</th>
		<th>Null value</th>
	  </tr>
	</thead>
	<tbody>	
	  <tr>
		<td><b>Hashtable</b></td>
		<td>Hash table</td>
		<td>No</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>No</td>
		<td>No</td>
	  </tr>		
	  <tr>
		<td><b>HashMap</b></td>
		<td>Hash table</td>
		<td>No</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
		<td>Yes</td>
	  </tr>
	  <tr>
		<td><b>LinkedHashMap</b></td>
		<td>Hash table and linked list</td>
		<td>Insertion or access order</td>
		<td>1</td>
		<td>Fail-fast</td>
		<td>Yes</td>
		<td>Yes</td>
	  </tr>
	  <tr>
		<td><b>TreeMap</b></td>
		<td>Red-Black tree</td>
		<td>Natural ordering of its keys</td>
		<td>log(n)</td>
		<td>Fail-fast</td>
		<td>No </td>
		<td>Yes</td>
	  </tr>
	  <tr>
		<td><b>ConcurrentHashMap</b></td>
		<td>Hash table</td>
		<td>No</td>
		<td>1</td>
		<td>Weakly consistent</td>
		<td>No</td>
		<td>No</td>
	  </tr>
	  <tr>
		<td><b>ConcurrentSkipListMap</b></td>
		<td>Skip list</td>
		<td>Natural ordering of its keys</td>
		<td>log(n)</td>
		<td>Weakly consistent</td>
		<td>No</td>
		<td>No</td>
	  </tr>
	</tbody>
	</table>	
	<p></p>
	
	<h2>ArrayList vs Vector</h2>
	<p>Vector is slower than ArrayList because Vector is synchronized.<br>
	Vector needs <i>external synchronization</i> because another thread can add an element right after isEmpty() and before add()</p>	
    <div class="code"><code><pre>Vector vector = new Vector();
synchronized (vector) {
    <i>// Only add an element if the vector is empty</i>
    if (vector.isEmpty()) {
        vector.add(1);
    }
}</pre></code></div>

	<h2>List vs Set</h2>
	<p>The Set interface (unordered) cannot contain duplicate elements, while the List interface (ordered) can.</p>	
    <div class="code"><code><pre>Set set = new HashSet();
set.add(1);
set.add(2);
set.add(1);</pre></code></div>
Output: [1, 2] (no exception)

	<h2>ArrayList vs LinkedList</h2>	
    <table border="1">
    <thead>
      <tr>
        <th>Operations</th>
        <th>ArrayList</th>
        <th>LinkedList</th>
        <th>Note</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>get(int index)</td>
        <td>O(1), faster</td>
        <td>O(n/4)</td>
        <td>Array: random access. LinkedList: start from the beginning</td>
      </tr>
      <tr>
        <td>remove(int index)<br>add(int index, E element)<br></td>
        <td>O(n/2)</td>
        <td>O(n/4), faster</td>
        <td>Array: new array, copy, shift. LinkedList: change pointer/reference</td>
      </tr>
    </tbody>
    </table>	
	<p><img src="images\linkedlist.jpeg" width="50%" height="50%"/>

  
  </body>
</html>
