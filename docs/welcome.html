<!doctype html>
<html>
  <head>
    <title>Welcome</title>
    <link rel="stylesheet" href="common.css">
  </head>
  <body>

  <u><b>OOP</b></u> (<b>O</b>bject-<b>O</b>riented <b>P</b>rogramming)<br> 
  <b>Interface</b>: Declares methods (signatures/prototypes of methods), <i>"what"</i> to do but <i>"not how"</i>to do (JPA), contract/agreement<br>
  <b>Abstract class</b>: cannot be instantiated, contains abstract methods to implement<br>
  <b>Principles</b>
  <ul>
      <li>Data Abstraction (Datenabstraktion): Visibility (private, protected)</li>
      <li>Encapsulation (Kapselung): Getters and Setters </li>
      <li>Inheritance (Vererbung): Subclass - Superclass</li>
      <li>Polymorphism (Polymorphismus): Many forms (overriding, overloading)</li>
  </ul>
  <b>IoC</b> (Inversion of Control): Dependency Injection: Framework does object creation (Guice, Dagger)<br>
  <b>Law of Demeter</b>: don't talk to strangers (A &rarr; B &rarr; C)<br>
  <b>Abstract Class versus Interface</b><br>
  <ul>
      <li>Method body: Abstract Class - if method is not abstract</li>
      <li>Constructors: Abstract Class</li>
      <li>Inheritance: Abstract Class - single, Interface - multiple</li>
      <li>Fields: Abstract Class - instance fields, Interface - constant fields</li>
  </ul>
  <b>Initialization Procedure</b>
  <ul>
      <li>static init block &rarr; static main() &rarr; super() &rarr; instance init block &rarr; constructor &rarr; myMethod</li>
  </ul>
  <br>
  <u><b>SOLID</b></u><br>
  <table>
    <tr>
      <td>
	    <b>S</b>ingle Responsibility: One reason for change<br>
	    <b>O</b>pen Closed: Open for extension but Closed for modification<br>
	    <b>L</b>iskov Substitution: Substitutable subclasses<br>
	    <b>I</b>nterface Segregation: Avoid "fat" interfaces<br> 
	    <b>D</b>ependency Inversion: Depend on Abstractions and Interfaces<br>	  
	  </td>
      <td>
	    <img src="images\uml_payment.png" width="30%" height="30%"/>
	  </td>
    </tr>
  </table>
  <br>  
  <u><b>MVC</b></u> (<b>M</b>odel <b>V</b>iew <b>C</b>ontroller)
  <ul>
      <li>Model: data (business logic, persistence, validation, conversion)</li>
      <li>View: presentation (UI: grids, trees, panels)</li>
      <li>Controller: handling user interactions (rendering, routing, instantiating)</li>
  </ul>
  <b>MVP</b> (<b>M</b>odel <b>V</b>iew <b>P</b>resenter)<br>
  <b>MVVM</b> (<b>M</b>odel <b>V</b>iew <b>V</b>iew<b>M</b>odel)<br>  
  <br>
  <u><b>UML</b></u> (<b>U</b>nified <b>M</b>odeling <b>L</b>anguage)<br>
  <table>
    <tr>
      <td>
        <b>Structure diagrams</b> (elements and relationships)
        <ul>
            <li>Class diagram</li>
            <li>Component diagram</li>
        </ul>
        <b>Behavior diagrams</b> (interactions and messaging)
        <ul>
            <li>Use case diagram</li>
            <li>Sequence diagram</li>
        </ul>
        <b>Relationships</b>: Association (Owner), Aggregation (Wheel), Composition (Frame) - bicycle<br>
	  </td>
      <td>
	    <img src="images\uml_product.png" width="75%" height="75%"/>
	  </td>
    </tr>
  </table>    
  <br>
  <u><b>Design Patterns</b></u><br>
  <b>Creational patterns</b>
  <ul>
      <li>Abstract Factory</li>
      <li>Factory Method</li>
      <li>Singleton: Use private constructor, share common data among objects (AppServices.isUserLoggedIn(), Runtime.exec())</li>
  </ul>
  <b>Structural patterns</b>
  <ul>
      <li>Composite</li>
      <li>Decorator</li>
  </ul>
  <b>Behavioral patterns</b>
  <ul>
      <li>Chain of Responsibility: Pass the request until an object handles it (GUI object tree)</li>
      <li>Observer: If one object changes, all dependents are notified and updated (MVC)</li>
      <li>Strategy: Replaceable methods (Payment Methods: PayPal, Credit Card)</li>
      <li>Template Method</li>
  </ul>
  <br>  
  <u><b>V-Model</b></u><br>
  <b>Verification</b>: Are you doing what is written?<br>
  <b>Validation</b>: Is the description good?<br>
  <b>Traceability</b>: vertical, horizontal<br>
  <b>Specification</b>: <i>Design Spec</i>, Architecture Spec, System <i>Req Spec</i>, User Req Spec<br>
  <b>Testing</b>: Component, Integration, System, Acceptance<br>    
  <br>
  <u><b>Cryptography</b></u><br>
  <b>Symmetric</b> (secret key)
  <ul>
    <li><i>Block cipher</i>: AES, DES, Twofish</li>
    <li><i>Stream cipher</i>: RC4</li>
  </ul>
  <b>Asymmetric</b> (public and private key): DSA, RSA<br>
  <b>Hash functions</b>: MD5, SHA<br>
  <br>
  <u><b>Method Parameters</b></u>
  <table border="1">
    <tr>
        <td></td>
        <td><b>Value type</b></td>
        <td><b>Reference type</b></td>
    </tr>
    <tr>
        <td><b>Pass by value (Java)</b></td>
        <td>Copy of data</td>
        <td>Copy of reference</td>
    </tr>
    <tr>
        <td><b>Pass by reference</b></td>
        <td>Data</td>
        <td>Reference</td>
    </tr>
  </table>
  <br>
  <table>
      <tbody>
          <tr>
              <td width="50%">
<pre>String str = new String(""); // int, Integer, ...
String strRef = str;
str = "abc"; // str = "abc", strRef = ""
StringBuilder strBuilder = new StringBuilder(); // Date, array, ...
StringBuilder strBuilderRef = strBuilder;
strBuilder.append("abc"); // strBuilder = "abc", strBuilderRef = "abc"</pre>
              </td>
              <td width="50%">
<pre>increment(int value) { value++; } // 0 &rarr; 0
increment(IntHolder ih) { ih.value++; } // 0 &rarr; 1
increment(IntHolder ih) { ih = new IntHolder(); ih.value++; } // 0 &rarr; 0</pre>
              </td>
          </tr>
      </tbody>
  </table>
  <br>  
  <u><b>Mutable and Immutable Objects</b></u><br>
  <b>Mutable</b> (modifiable): StringBuffer, StringBuilder, Date, Vector, ...<br>
  <b>Immutable</b>: String, Instant, record, Integer, ...<br>
  <b>Thread-safe</b>: String (immutable), StringBuffer (synchronized)<br>  
  <br>
  <u><b>Collection API</b></u><br>
  <b>Vector</b>: synchronized<br>
  <b>ArrayList</b>: not synchronized<br>
  <b>LinkedList</b>: get - slow, add/remove: fast<br>
  <b>CopyOnWriteArrayList</b>: thread-safe (copy instead of synchronization)<br>
  <b>HashSet</b>: unordered, no duplicate<br>
  <br>
  <u><b>Exceptions</b></u><br>
  <b>Checked</b> (compile time) or <b>Unchecked</b> (run time)<br>
  <b>try-with-resources</b> (<i>AutoCloseable</i>): try (InputStream in = ...) { ... }<br>
  <br>
  <u><b>Garbage Collection</b></u><br>
  Automatic reclaimer on the <i>heap</i> (Serial, Parallel, CMS, G1)<br>
  <br>
  <u><b>Multithreading</b></u><br>
  <pre>class MyThread extends Thread { run() {} } ... new MyThread().start();
class MyRunnable implements Runnable { run() {} } ... new Thread(runnable).start();</pre>
  <b>Lambda Expression</b>: Runnable runnable = () -> System.out.println("New thread created"); new Thread(runnable).start();<br>
  <b>Methods</b>: isAlive, setDaemon, start, run, join<br>
  <br>
  <u><b>Comparison</b></u><br>
  <pre><b>Interface Comparable&lt;T&gt;</b> // single sorting
public int compareTo(Shape o) {}
Collections.sort(shapes);
<b>Interface Comparator&lt;T&gt;</b> // multiple sorting
public int compare(Shape o1, Shape o2) {}
Collections.sort(shapes, new ShapeComparer());</pre>
  <br>
  <u><b>Stream API</b></u><br>
  <b>Intermediate operations</b>: filter, map (stateless); distinct, sorted (stateful)<br>
  <b>Terminal operations</b>: forEach, reduce, sum, collect; anyMatch, findFirst, groupingBy<br>
  <b>filter-map-reduce</b> examples<br>	  
  <ul>
      <li><pre>products.stream().filter(p -&gt; p.getCategory().getName().equals("Beverages")).mapToDouble(p -&gt; p.getPrice()).sum();</pre></li>
      <li><pre>products.stream().map(Product::getName).collect(Collectors.toList());</pre></li>			 
      <li><pre>IntStream.range(0, 5).boxed().map(x -&gt; x * 2).collect(Collectors.toList());</pre></li>
      <li><pre>Map&lt;String, List&lt;Product&gt;&gt; map = products.stream().collect(Collectors.groupingBy(p -&gt; p.getCategory().getName()));
map.values().stream().flatMap(List::stream).forEach(System.out::println);</pre></li>
  </ul>		  
  <br>
  
  <u><b>JUnit</b></u><br>
  <b>JUnit4</b> 
  <ul>
      <li><pre>@BeforeClass, @AfterClass, @Before, @After, @Test</pre></li>
      <li><pre>@RunWith(Parameterized.class), @Parameters + constructor</pre></li>
  </ul>
  <b>JUnit5</b> 
  <ul>
      <li><pre>@BeforeAll, @AfterAll, @BeforeEach, @AfterEach, @Test</pre></li>
      <li><pre>@ParameterizedTest, @ValueSource(ints = {1, 3, 5}), @MethodSource + Stream</pre></li>
  </ul>
  <br>
  
  <u><b>SQL</b></u> (<b>S</b>tructured <b>Q</b>uery <b>L</b>anguage)<br>
  <b>Stored Procedures</b>: saved SQL code to reuse again<br>
  <b>Triggers</b>: stored procedure that runs when an event occurs<br>
  <b>Indexes</b>: quick queries, on columns that are frequently searched<br>
  <b>JDBC</b> (<b>J</b>ava <b>D</b>ata<b>B</b>ase <b>C</b>onnectivity)
  <ul>
  <li>Statement: executeQuery, executeUpdate, executeBatch</li>
  <li>Connection: setAutoCommit, commit, rollback</li>
  </ul> 
  <b>Queries</b>  
  <ul><li><pre>SELECT categories.name, products.name AS most_expensive_product
FROM categories 
INNER JOIN products ON categories.category_id = products.category_id
WHERE categories.name IN ('Beverages', 'Confections') AND products.price > 50 
GROUP BY categories.name
HAVING MAX(products.price)
ORDER BY products.price DESC
LIMIT 3;</pre></li></ul>
  <b>Updates</b> 
  <ul><li><pre>CREATE/DROP TABLE ..., INSERT INTO ... VALUES ..., UPDATE ..., DELETE FROM ..., ALTER TABLE ...</pre></li>
<li><pre>CREATE TYPE stock_status AS ENUM ('not available', 'in stock', 'discontinued');
CREATE TABLE products (
    product_id       serial PRIMARY KEY,
    category_id      integer REFERENCES categories(category_id) NOT NULL, 
    product_number   varchar(50) UNIQUE NOT NULL,	
    name             varchar(50) NOT NULL,
    description      text,
    image            bytea,
    price            numeric(10,2) CHECK (price > 0),
    status           stock_status NOT NULL, 
    created_at       timestamp DEFAULT CURRENT_TIMESTAMP
);</pre></li></ul>
  <br>
  <u><b>REST API</b></u> (<b>RE</b>presentational <b>S</b>tate <b>T</b>ransfer - <b>A</b>pplication <b>P</b>rogramming <b>I</b>nterface)
  <ul>
      <li>Client-server architecture</li>
      <li>Stateless protocol</li>
      <li>Caching</li>
      <li>Uniform interface</li>
      <li>Layered system</li>
      <li>Code on demand (optional)</li>
  </ul>
  <b>Request methods</b>
  <table border="1">
    <tr>
      <td>GET</td>
      <td>Retrieve</td>
      <td>/products/{id}</td>
      <td></td>
    </tr>
    <tr>
      <td>POST</td>
      <td>Create</td>
      <td>/products</td>
      <td></td>
    </tr>
    <tr>
      <td>PUT</td>
      <td>Update</td>
      <td>/products/{id}</td>
      <td>idempotent: create if not exist</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>Delete</td>
      <td>/products/{id}</td>
      <td></td>
    </tr>
  </table>  
  <b>JAX-RS </b>(Specification): <b>J</b>ava <b>A</b>PI for <b>R</b>ESTful Web <b>S</b>ervices 
  <ul>
      <li>Reference Implementation: Jersey</li>
      <li>Other implementations: RESTeasy, Apache CXF, Restlet</li>
  </ul>
  
  <u><b>TODO below !!!</b></u><br>
  <br>
  <u><b>GoF Design Patterns Usage in Spring Boot Microservices</b></u><br>
  <table border="1"><thead>
    <tr>
      <th>Design Pattern</th>
      <th>Intent</th>
      <th>Usage</th>
      <th>Usage</th>
      <th>Lombok Annotation</th>
    </tr></thead>
  <tbody>
    <tr>
      <td>Singleton</td>
      <td>Ensures a single instance of a class </td>
      <td>Service beans, configuration classes, and resource management</td>
      <td>Spring beans are singletons by default, ensuring one shared instance per application</td>
      <td>@UtilityClass </td>
    </tr>
    <tr>
      <td>Factory Method</td>
      <td>Creates objects without specifying the concrete class</td>
      <td>Configuration, bean instantiation, or when object creation is complex</td>
      <td>BeanFactory and FactoryBean abstractions decouple object creation from application logic</td>
      <td></td>
    </tr>
    <tr>
      <td>Strategy</td>
      <td>Enables selecting algorithms at runtime</td>
      <td>Flexible services where logic needs to be pluggable or configurable</td>
      <td>Conditional beans and pluggable services let you swap algorithms without changing clients</td>
      <td></td>
    </tr>
    <tr>
      <td>Template Method</td>
      <td>Defines a method skeleton, letting subclasses fill in details</td>
      <td>Abstract base services and workflow definitions</td>
      <td>RestTemplate, JdbcTemplate, and others define skeleton workflows while allowing customization</td>
      <td></td>
    </tr>
    <tr>
      <td>Proxy</td>
      <td>Adds extra behavior to objects</td>
      <td>AOP, security, remote service calls, caching, service abstraction</td>
      <td>AOP and transaction management rely on proxies to wrap and enhance method execution</td>
      <td></td>
    </tr>
    <tr>
      <td>Observer</td>
      <td>Allows objects to subscribe to events</td>
      <td>Event-driven architecture, message queues, and domain event handling</td>
      <td>ApplicationEventPublisher and @EventListener support loosely coupled event-driven communication</td>
      <td></td>
    </tr>
    <tr>
      <td>Builder</td>
      <td>Simplifies object creation</td>
      <td>Building DTOs, HTTP request bodies, or configurations fluently</td>
      <td>WebClient, RequestEntity, and ResponseEntity use builders to construct complex requests safely</td>
      <td>@Builder, @Singular, @SuperBuilder</td>
    </tr>
    <tr>
      <td>Adapter</td>
      <td>Converts one interface into another, bridges incompatible interfaces</td>
      <td>Integrating legacy systems or external APIs</td>
      <td>Feign client interfaces and messaging converters adapt external APIs to your domain model</td>
      <td></td>
    </tr>
    <tr>
      <td>Decorator</td>
      <td>Adds responsibilities dynamically</td>
      <td>Request/response filters and enhancing behavior without inheritance</td>
      <td>Servlet filters and HttpMessageConverters wrap requests/responses to add cross-cutting behavior</td>
      <td>@Delegate </td>
    </tr>
    <tr>
      <td>Command</td>
      <td>Encapsulates a request as an object</td>
      <td>Task execution, messaging systems, or scheduling commands, async/job handling</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Chain of Responsibility</td>
      <td>Passes a request along handlers</td>
      <td>Middleware, filters, and validation pipelines</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Composite</td>
      <td>Composes objects into tree structures</td>
      <td>Resource trees or nested component hierarchies</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Mediator</td>
      <td>Centralizes complex communication between objects. Reduces coupling between components.</td>
      <td>Rare in Spring due to ApplicationContext; used when many components interact</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Flyweight</td>
      <td>Shares object state efficiently</td>
      <td>Caching or large-volume data structures</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Memento</td>
      <td>Captures and restores object state</td>
      <td>Rarely used; applicable in undo mechanisms or versioning</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Interpreter</td>
      <td>Defines grammar and interprets expressions</td>
      <td>Custom DSLs or expression evaluators</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Visitor</td>
      <td>Adds operations to objects without changing them</td>
      <td>Rare in Spring; used when operations on structured data are needed</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Bridge</td>
      <td>Separates abstraction from implementation</td>
      <td>Rarely used; useful when you want to vary implementations independently.</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Facade</td>
      <td></td>
      <td></td>
      <td>Service facades simplify complex subsystem interactions behind a unified interface</td>
      <td></td>
    </tr>
  </tbody></table>
  
  <br>
  <u><b>Scopes (DI lifetime types)</b></u><br>
  <table border=1><thead>
    <tr>
      <th>Scope</th>
      <th>ASP.NET Core</th>
      <th>Spring Boot Annotation</th>
      <th>Angular Syntax</th>
      <th>Behavior</th>
      <th>Use Case </th>
    </tr></thead>
  <tbody>
    <tr>
      <td>Singleton</td>
      <td>AddSingleton </td>
      <td>@Component / @Service (default)</td>
      <td>@Injectable({ providedIn: 'root' })</td>
      <td>One instance per application </td>
      <td>Stateless shared services, cache managers </td>
    </tr>
    <tr>
      <td>Prototype</td>
      <td>AddTransient </td>
      <td>@Scope("prototype")</td>
      <td>providers: [MyService] (on component)</td>
      <td>New instance on each injection </td>
      <td>Stateful or non-thread-safe beans </td>
    </tr>
    <tr>
      <td>Request</td>
      <td>AddScoped </td>
      <td>@Scope("request") or @RequestScope</td>
      <td>Not applicable. Simulate by using Injector.create() in an HTTP interceptor or providing the service at a request boundary (e.g., in a resolver)</td>
      <td>New instance per HTTP request </td>
      <td>Request-scoped controllers, filters </td>
    </tr>
    <tr>
      <td>Session</td>
      <td></td>
      <td>@Scope("session")</td>
      <td>Not applicable</td>
      <td></td>
      <td>Session-scoped user data, shopping cart beans </td>
    </tr>
    <tr>
      <td>Application</td>
      <td></td>
      <td>@Scope("application")</td>
      <td>@Injectable({ providedIn: 'root' }) (default)</td>
      <td></td>
      <td>Global resources, application-wide configuration </td>
    </tr>
    <tr>
      <td>Component-scoped</td>
      <td></td>
      <td>Not applicable</td>
      <td>providers: [MyService] (in component metadata)</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Module-scoped</td>
      <td></td>
      <td>Not standard</td>
      <td>Declare service in module’s providers: [...]</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>Lazy-loaded module</td>
      <td></td>
      <td>Not applicable</td>
      <td>Lazy-load module and provide service locally</td>
      <td></td>
      <td></td>
    </tr>
  </tbody></table>  
  
  
  <b>Spring Boot:</b><br>
  - Default: singleton<br>
  - Used with @Scope("...") on @Component, @Service, @Bean, etc.<br>
  <b>Angular:</b><br>
  - Default: providedIn: 'root' → Singleton across the entire app.<br>
  - Use component/module providers to create scoped instances.<br>
  
  <pre>

---------------------------------------------------------

Use of @Bean and @primary?
Use of @conditional?
How to create rest api explain?
@RestController default return type? (plain text, Jackson)

bemásolni a régi intervoew icell + otp

<b>Liquibase</b>: adatbázis séma migráció (verzió), YAML:  (changes: createTable)

<b>annotation</b>: @interface MyAnnotation { String value(); }

<b>AWS</b> 
	RDS = SQL-alapú adatbázisokat futtathatsz vele, például MySQL, PostgreSQL vagy SQL Server — teljesen felügyelt, nem kell manuálisan telepítgetni. 
	IAM = ideiglenes jogosultság
	EC2 = virtuális szervert biztosít hosszú futású folyamatokhoz
		Virtuális szerverek futtatására szolgál a felhőben. Olyan, mintha saját géped lenne, de online és rugalmasan méretezhető
	Lambda = eseményvezérelt, rövid futású kód végrehajtására alkalmas szerver nélkül.
	S3 = Fájlok, adatok tárolására használt tárhely
	Amazon CloudFront: Tartalomelosztó (CDN), ami gyorsítja a weboldalak betöltését világszerte — például képek, videók gyorsabb elérését biztosítja a felhasználóknak.

<b>Java 21</b>
- Virtual Threads (by the JVM): Thread.startVirtualThread
- Pattern Matching for switch: típusokra elágazni (obj --> Integer / String)
- Record Patterns: recordból adatkinyerés egy switch-el

<b>perf:</b>
	Adatbázis-particionálás: Oszd fel nagy táblákat logikai részekre (pl. dátum vagy régió alapján), hogy gyorsabb lekérdezéseket kapj.
	Aszinkron kommunikáció: Használj üzenetsorokat (pl. Kafka, RabbitMQ), hogy ne blokkolják egymást a szolgáltatások.
	Caching (pl. Redis, Memcached): Tárold az ismétlődő adatokat memóriában, hogy ne kelljen minden kérésnél újra számolni vagy lekérdezni.
	Database connection pooling: Minimalizáld az adatbázis-kapcsolatok létrehozásának költségét, oszd meg őket hatékonyan.
	Load balancing: Oszd el a kéréseket több példány között, hogy ne terhelődjön túl egyetlen szolgáltatás.
	gRPC vagy más hatékony protokoll: REST helyett használj bináris protokollokat, ha alacsony késleltetésre van szükség.
	Rate limiting és throttling: Védd a szolgáltatásokat a túlterheléstől, szabályozd a bejövő kérések számát.
	Kód optimalizálás és footprint csökkentés: Minimalizáld a szolgáltatás méretét, csak a szükséges logikát tartsd meg, így gyorsabban indul és fut.	
	Load Balancing és Service Discovery
		Forgalom egyenletes elosztása szolgáltatások között (pl. Envoy, Istio).
		Dinamikus felfedezés skálázódó mikroszolgáltatásokhoz.
	retry policy
  
  </pre>
  
  </body>
</html>