<!doctype html>
<html>
  <head>
    <title>Welcome</title>
    <link rel="stylesheet" href="common.css">
  </head>
  <body>

  <u><b>REST API</b></u><br>
  <b>REST API</b> (<b>RE</b>presentational <b>S</b>tate <b>T</b>ransfer - <b>A</b>pplication <b>P</b>rogramming <b>I</b>nterface)
  <ul>
      <li>Client-server architecture</li>
      <li>Stateless protocol</li>
      <li>Caching</li>
      <li>Uniform interface</li>
      <li>Layered system</li>
      <li>Code on demand (optional)</li>
  </ul>
  <b>Request methods</b>
  <ul>
      <li>GET: Retrieve </li>
      <li>POST: Create </li>
      <li>PUT: Update (Create if not exist)</li>
      <li>DELETE: Delete</li>
  </ul>
  <b>JAX-RS </b>(Specification): <b>J</b>ava <b>A</b>PI for <b>R</b>ESTful Web <b>S</b>ervices 
  <ul>
      <li>Reference Implementation: Jersey</li>
      <li>Other implementations: RESTeasy, Apache CXF, Restlet</li>
  </ul>
  <br>
  <u><b>Model-View-Controller</b></u><br>
  <b>MVC</b> (<b>M</b>odel <b>V</b>iew <b>C</b>ontroller)
  <ul>
      <li>Model: data (business logic, persistence, validation, conversion)</li>
      <li>View: presentation (UI: grids, trees, panels)</li>
      <li>Controller: handling user interactions (rendering, routing, instantiating)</li>
  </ul>
  <b>MVP</b> (<b>M</b>odel <b>V</b>iew <b>P</b>resenter)<br>
  <b>MVVM</b> (<b>M</b>odel <b>V</b>iew <b>V</b>iew<b>M</b>odel)<br>
  <br>
  <u><b>Design Patterns</b></u><br>
  <b>Creational patterns</b>
  <ul>
      <li>Abstract Factory</li>
      <li>Factory Method</li>
      <li>Singleton: One global instance, private constructor (Runtime.exec())</li>
  </ul>
  <b>Structural patterns</b>
  <ul>
      <li>Composite</li>
      <li>Decorator</li>
  </ul>
  <b>Behavioral patterns</b>
  <ul>
      <li>Chain of Responsibility: Pass the request until an object handles it (GUI object tree)</li>
      <li>Observer: If one object changes, all dependents are notified and updated (MVC)</li>
      <li>Strategy: Replaceable methods (Payment Methods: PayPal, Credit Card)</li>
      <li>Template Method</li>
  </ul>
  <br>
  <u><b>Object-Oriented Programming (OOP)</b></u><br>
  <b>Interface</b>: Declares methods (signatures/prototypes of methods), <i>"what"</i> to do but <i>"not how" </i>to do (JPA), contract/agreement<br>
  <b>Annotation</b> (a form of metadata): @interface MyAnnotation { String element1(); }<br>
  <b>Principles</b>
  <ul>
      <li>Data Abstraction: Visibility (private, protected)</li>
      <li>Encapsulation: Getters and Setters </li>
      <li>Inheritance: Subclass - Superclass</li>
      <li>Polymorphism: Many forms (overriding, overloading)</li>
  </ul>
  <b>IoC</b> (Inversion of Control): Dependency Injection: Framework does object creation (Guice, Dagger)<br>
  <b>Law of Demeter</b>: don&apos;t talk to strangers (A &rarr; B &rarr; C)<br>
  <b>Abstract Class versus Interface</b><br>
  <ul>
      <li>Method body: Abstract Class - if method is not abstract</li>
      <li>Constructors: Abstract Class</li>
      <li>Inheritance: Abstract Class - single, Interface - multiple</li>
      <li>Fields: Abstract Class - instance fields, Interface - constant fields</li>
  </ul>
  <b>Initialization Procedure</b>
  <ul>
      <li>static init block &rarr; static main() &rarr; super() &rarr; instance init block &rarr; constructor &rarr; myMethod</li>
  </ul>
  <br>
  <u><b>SOLID</b></u><br>
  <b>S</b>ingle Responsibility: One reason for change<br>
  <b>O</b>pen Closed: Open for extension but Closed for modification<br>
  <b>L</b>iskov Substitution: Substitutable subclasses<br>
  <b>I</b>nterface Segregation: Avoid "fat" interfaces<br> 
  <b>D</b>ependency Inversion: Depend on Abstractions and Interfaces<br>
  <br>
  <u><b>Unified Modeling Language (UML)</b></u><br>
  <b>Structural diagrams</b>
  <ul>
      <li>Class diagram</li>
      <li>Component diagram</li>
  </ul>
  <b>Behavioral diagrams</b>
  <ul>
      <li>Use case diagram</li>
      <li>Sequence diagram</li>
  </ul>
  <b>Relationships</b>: Association (Owner), Aggregation (Wheel), Composition (Frame) - bicycle<br>
  <br>
  <u><b>V-Model</b></u><br>
  <b>Verification</b>: Are you doing what is written?<br>
  <b>Validation</b>: Is the description good?<br>
  <br>
  <u><b>Cryptography</b></u>
  <ul>
      <li><b>Symmetric</b> (secret key)
          <ul>
              <li>
                  <i>Block cipher</i>: AES, DES, Twofish
              </li>
              <li>
                  <i>Stream cipher</i>: RC4
              </li>
          </ul>
      </li>
      <li><b>Asymmetric</b> (public and private key): DSA, RSA</li>
      <li><b>Hash functions</b>: MD5, SHA</li>
  </ul>
  <br>
  <u><b>Method Parameters</b></u>
  <table border="1">
      <tbody>
          <tr>
              <td></td>
              <td><b>Value type</b></td>
              <td><b>Reference type</b></td>
              <td></td>
          </tr>
          <tr>
              <td><b>Pass by value (Java)</b></td>
              <td>Copy of data</td>
              <td>Copy of reference</td>
              <td></td>
          </tr>
          <tr>
              <td><b>Pass by reference</b></td>
              <td>Data</td>
              <td>Reference</td>
              <td></td>
          </tr>
      </tbody>
  </table>
  <br>
  <table>
      <tbody>
          <tr>
              <td width="50%">
                  String str = new String(""); // int, Integer, ...<br>
                  String strRef = str;<br>
                  str = "abc"; // str = "abc", strRef = ""<br>
                  StringBuilder strBuilder = new StringBuilder(); // Date, array, ...<br>
                  StringBuilder strBuilderRef = strBuilder;<br>
                  strBuilder.append("abc"); // strBuilder = "abc", strBuilderRef = "abc"
              </td>
              <td width="50%">
                  increment(int value) { value++; } // 0 &rarr; 0<br>
                  increment(IntHolder ih) { ih.value++; } // 0 &rarr; 1<br>
                  increment(IntHolder ih) { ih = new IntHolder(); ih.value++; } // 0 &rarr; 0
              </td>
          </tr>
      </tbody>
  </table>
  <br>
  <u><b>Collection API</b></u>
  <ul>
      <li>Vector: synchronized</li>
      <li>ArrayList: not synchronized</li>
      <li>LinkedList: get - slow, add/remove: fast</li>
      <li>CopyOnWriteArrayList: thread-safe (copy instead of synchronization)</li>
      <li>HashSet: unordered, no duplicate</li>
  </ul>
  <br>
  <u><b>Exceptions</b></u><br>
  Checked (compile time) or Unchecked (run time)<br>
  try-with-resources (AutoCloseable): try (InputStream in = ...) { ... }<br>
  <br>
  <u><b>Garbage Collection</b></u><br>
  Automatic reclaimer on the heap (Serial, Parallel, CMS, G1)<br>
  <br>
  <u><b>JUnit</b></u><br>
  JUnit4: 
  <ul>
      <li>@BeforeClass, @AfterClass, @Before, @After, @Test</li>
      <li>@RunWith(Parameterized.class), @Parameters + constructor</li>
  </ul>
  JUnit5: 
  <ul>
      <li>@BeforeAll, @AfterAll, @BeforeEach, @AfterEach, @Test </li>
      <li>@ParameterizedTest, @ValueSource(ints = {1, 3, 5}), @MethodSource + Stream</li>
  </ul>
  <br>
  <u><b>Multithreading</b></u><br>
  class MyThread extends Thread { run() {} } &rarr; new MyThread().start();<br>
  class MyRunnable implements Runnable { run() {} } &rarr; new Thread(runnable).start();<br>
  Lambda Expression: Runnable runnable = () &rarr; System.out.println("New thread created"); new Thread(runnable).start();<br>
  Methods: isAlive, setDaemon, start, run, join<br>
  <br>
  <u><b>Mutable and Immutable Objects</b></u><br>
  Mutable (modifiable): StringBuffer, StringBuilder, Date, Vector, ...<br>
  Immutable: String, Instant, record, Integer, ...<br>
  Thread-safe: String (Immutable), StringBuffer (Synchronized)<br>
  <br>
  <u><b>Comparison</b></u><br>
  <b>Interface Comparable&lt;T&gt;</b> // single sorting<br>
  public int compareTo(Shape o) {}<br>
  Collections.sort(shapes);<br>
  <b>Interface Comparator&lt;T&gt;</b> // multiple sorting<br>
  public int compare(Shape o1, Shape o2) {}<br>
  Collections.sort(shapes, new ShapeComparer());<br>
  <br>
  <u><b>Stream API</b></u>
  <ul>
      <li>Intermediate operations: filter, map (stateless); distinct, sorted (stateful) </li>
      <li>Terminal operations: forEach, reduce, sum, collect; anyMatch, findFirst, groupingBy</li>
      <li>filter-map-reduce examples: 
          <ul>
              <li>
                  employees.stream().filter(e -&gt; e.getDepartment().equals("HR")).mapToInt(e -&gt; e.getSalary()).sum();
              </li>
              <li>
                  employees.stream().map(Employee::getName).collect(Collectors.toList());
              </li>
              <li>
                  IntStream.range(0, 5).boxed().map(x -&gt; x * 2).collect(Collectors.toList());
              </li>
              <li>
                  Map&lt;String, List&lt;Employee&gt;&gt; map = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment));<br> map.values().stream().flatMap(List::stream).forEach(System.out::println);
              </li>
          </ul>
      </li>
  </ul>
  
  <u><b>Structured Query Language (SQL)</b></u><br>
  <pre>
  <b>SELECT</b> Country, COUNT(CustomerID) AS TotalCustomers
  FROM Customers
  WHERE Country IN ('Germany','UK') AND Age>30
  GROUP BY Country
  HAVING COUNT(CustomerID) > 5
  ORDER BY Country DESC;
  <b>SELECT</b> * FROM A INNER JOIN B ON A.Key=B.Key;
  <b>CREATE</b> TABLE ..., INSERT INTO ..., UPDATE ..., DELETE ...
  <b>CREATE</b> TABLE orders (
      order_id     serial PRIMARY KEY,
      customer_id  integer REFERENCES customers(customer_id) NOT NULL, 
      order_number varchar(40) NOT NULL,
      description  text,
      order_date   timestamp,
      status       order_status,
      total        numeric
  );</pre>
  <b>Stored Procedures</b>: saved SQL code to reuse again<br>
  <b>Triggers</b>: stored procedure that runs when an event occurs<br>
  <b>Indexes</b>: quick queries, on columns that are frequently searched<br>
  <b>Java DataBase Connectivity (JDBC)</b> 
  <ul>
  <li>Statement: executeQuery, executeUpdate, executeBatch</li>
  <li>Connection: setAutoCommit, commit, rollback</li>
  </ul>
  
  </body>
</html>