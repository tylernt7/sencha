<!doctype html>
<html>
  <head>
    <title>Message Queue</title>
    <link rel="stylesheet" href="../common.css">
  </head>
  <body>
    <h1>Message Queue</h1>
	
    <h2>Overview (ToDo - KnorrBremse)</h2>
Communication between an iCOM OCU on a moving vehicle and the related offboard system has to cope with networks prone to disruptions (poor mobile radio network coverage in rural areas, train in tunnel etc.). For robust operation on both sides on one hand and guaranteed transmission of information on the other, asynchronous, message base data transfer has been chosen as the solution for this challenge.<br>
For robustness and flexibility, communication between components of the offboard system is also realized via messaging, at least where communication takes place across server boundaries.<br>
A central element in message based communication is the message broker, which receives messages from connected systems and delivers them to interested parties. Two basic mechanisms are available to send and receive messages:<br>
Queues: a producer can send a message to a queue. On the other side, there can be one or more message consumers. The consumer which comes first reads the message, and the message is deleted from the queue.<br>
Topic: a producer can send a message to a topic. All interested consumers can read a copy of the message, without the first one deleting it from the topic.<br>
As implementation of the message broker, ActiveMQ has been selected. It delivers a rich, stable set of message broker functions, like persistent caching of messages which cannot be delivered at once, failover and load sharing configurations of brokers, SSL secured communication, and network connectors for different communication protocols (tcp, MQTT etc.). Furthermore, ActiveMQ can be easily extended by using Camel as message routing engine.<br>
The message broker architecture and the message routing concept are critical for iCOMs robustness, performance and extensibility. For a growing productive environment, rules have to be set and followed for creation and use of queues, topics and routes. Setting these rules is the aim of this document.<br>

    <h2>SOI 5.3.6 Loss of messages, due to large volume of messages getting queued-up in ActiveMQ (ToDo - KnorrBremse)</h2>
Since Active-MQ buffers messages in a database (kahadb), messages can only get lost, when this database overflows. This can be due to an Amq configuration, that made the database small or due to disk overflow.<br>
Please be aware, that after a connection outage (or a scheduled connection shutdown), the back office will be flooded with messages from all devices after reconnect.<br>
This can cause very high temporary volume of messages.<br>

    <h2>RabbitMQ</h2>
	<center><img src="images\mq_broker.png" width="25%" height="25%"/></center>	
	<h3>Exchanges and Exchange Types</h3>
	<p><b>Exchanges</b> are AMQP 0-9-1 entities where messages are sent to. Exchanges take a message and route it into zero or more queues. The routing algorithm used depends on the <b>exchange type</b> and rules called <b>bindings</b>.</p>
	<h3>Exchange Types</h3>
	<p>AMQP 0-9-1 brokers provide four exchange types:</p>
	<b>Direct Exchange</b> (default exchange): Every queue that is created is automatically bound to the default exchange with a routing key which is the same as the queue name. A message goes to the queues whose binding key exactly matches the routing key of the message. It can be used for unicast (one-to-one) and multicast (one-to-many) routing as well.<br>
	<center><img src="images\mq_direct.png" width="50%" height="50%"/></center>
	<b>Fanout Exchange</b>: A fanout exchange routes messages to all of the queues that are bound to it and the routing key is ignored. If N queues are bound to a fanout exchange, when a new message is published to that exchange a copy of the message is delivered to all N queues. It can be used for broadcast (one to all) routing.<br>
	<center><img src="images\mq_fanout.png" width="50%" height="50%"/></center>	
	<b>Topic Exchange</b>: Topic exchanges route messages to one or many queues based on matching between a message routing key and the pattern that was used to bind a queue to an exchange. It can be used for multicast (one-to-many) routing.<br>
	The routing key must be a list of words, delimited by dots. The binding key must also be in the same form. However there are two special cases for binding keys:<br>
	* (star) can substitute for exactly one word.<br>
	# (hash) can substitute for zero or more words.<br>
	When a queue is bound with "#" (hash) binding key - it will receive all the messages, regardless of the routing key - like in fanout exchange. When special characters "*" (star) and "#" (hash) aren't used in bindings, the topic exchange will behave just like a direct one.<br>	
	<center><img src="images\mq_topic.png" width="50%" height="50%"/></center>
	<b>Headers Exchange</b> (match exchange): Headers exchange routes messages to the queue based on the headers ('headers' property) of the message that matches the arguments with which the queue was bound. The routing key is not used. It can be used for unicast, multicast and broadcast routing. The 'headers' property contains a table (hash or dictionary) of names and values. The 'x-match' binding argument can take one of two values, dictating how the rest of the name value pairs in the table are treated during matching:<br>
	<ul>
	<li>'all' implies that all the other pairs must match the 'headers' property of a message for that message to be routed (i.e. an AND match)</li>
	<li>'any' implies that the message should be routed if any of the fields in the 'headers' property match one of the fields in the arguments table (i.e. an OR match)</li>
	</ul>
	Any field starting with 'x-' other than 'x-match' is reserved for future use and will be ignored<br>		
	<i>Binding the queues to the exchange</i><br>
	A message has a payload (body) and one or more message properties (e.g. headers).<br>
	<div class="code"><code><pre>Map&lt;String, Object> headers = new HashMap&lt;String, Object>(); // bindingArgs
headers.put("x-match", "any"); // any or all
headers.put("headerName#1", "headerValue#1");
headers.put("headerName#2", "headerValue#2");</pre></code></div><br>
    <center><img src="images\mq_headers.png" width="50%" height="50%"/></center>	

	<h3>Topic Exchange (Java)</h3>
	
    <div class="code"><code><pre>private static final String EXCHANGE_NAME = "topic-exchange";
<i>// Create a connection factory and a connection</i>
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
try (Connection connection = factory.newConnection();
<i>// Create a channel</i>
Channel channel = connection.createChannel()) {
    <i>// Declare a topic exchange</i>
    channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
    
    <i>// Declare a queue</i>
    String queueName = channel.queueDeclare("weather_queue", false, false, false, null).getQueue();
    
    <i>// Bind the queue to the exchange with a binding key</i>
    <i>// For example, "weather." means any message with a routing key that starts with "weather."</i>
    String bindingKey = "weather.";
    channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);
    
    <i>// Create a consumer</i>
    DeliverCallback deliverCallback = (consumerTag, delivery) -> {
        String message = new String(delivery.getBody(), "UTF-8");
        String routingKey = delivery.getEnvelope().getRoutingKey();
        System.out.println(" [x] Received '" + routingKey + "':'" + message + "'");
    };
    <i>// Consume messages from the queue</i>
    channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });
    
    <i>// Publish messages to the exchange with different routing keys</i>
    <i>// For example, "weather.rainy" means a rainy weather message</i>
    String routingKey = "weather.rainy";
    String message = "A rainy weather error";
    byte[] body = message.getBytes("UTF-8");
    channel.basicPublish(EXCHANGE_NAME, routingKey, null, body);
    System.out.println(" [x] Sent '" + routingKey + "':'" + message + "'");
}</pre></code></div>

	<h3>Topic Exchange (C#)</h3>
    <div class="code"><code><pre>private const string EXCHANGE_NAME = "topic-exchange";
<i>// Create a connection factory and a connection</i>
var factory = new ConnectionFactory() { HostName = "localhost" };
using(var connection = factory.CreateConnection())
<i>// Create a channel</i>
using(var channel = connection.CreateModel())
{
    <i>// Declare a topic exchange</i>
    channel.ExchangeDeclare(exchange: EXCHANGE_NAME, type: ExchangeType.Topic);
    
    <i>// Declare a queue</i>
    var queueName = channel.QueueDeclare(queue: "weather_queue", durable: false, exclusive: false, autoDelete: false, arguments: null).QueueName;
    
    <i>// Bind the queue to the exchange with a binding key</i>
    <i>// For example, "weather." means any message with a routing key that starts with "weather."</i>
    var bindingKey = "weather.";
    channel.QueueBind(queue: queueName, exchange: EXCHANGE_NAME, routingKey: bindingKey);
    
    <i>// Create a consumer</i>
    var consumer = new EventingBasicConsumer(channel);
    consumer.Received += (model, ea) =>
    {
        var body = ea.Body;
        var message = Encoding.UTF8.GetString(body);
        var routingKey = ea.RoutingKey;
        Console.WriteLine(" [x] Received '{0}':'{1}'", routingKey, message);
    };
    <i>// Consume messages from the queue</i>
    channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer);
    
    <i>// Publish messages to the exchange with different routing keys</i>
    <i>// For example, "weather.rainy" means a rainy weather message</i>
    var routingKey = "weather.rainy";
    var message = "A rainy weather error";
    var body = Encoding.UTF8.GetBytes(message);
    channel.BasicPublish(exchange: EXCHANGE_NAME, routingKey: routingKey, basicProperties: null, body: body);
    Console.WriteLine(" [x] Sent '{0}':'{1}'", routingKey, message);
}</pre></code></div>
	
	<h2>Consumer Acknowledgements and Publisher Confirms</h2>
	Systems that use a messaging broker are distributed.<br>
	Delivery processing acknowledgements from consumers to RabbitMQ are known as <b>consumer acknowledgements</b>: when RabbitMQ delivers a message to a consumer, RabbitMQ needs to know when to consider the message to be successfully sent. RabbitMQ delivers messages to the consumer with a <b>delivery tag</b>, which uniquely identifies the delivery on a channel. The default consumer acknowledgement mode is automatic acknowledgement ("fire-and-forget"), which is unsafe because it can cause data loss (cannot detect failures) but it is faster and simpler than manual acknowledgement mode (channel.basicAck). A "prefetch count" value (using the basic.qos method) defines the max number of unacknowledged deliveries that are permitted on a channel. When the number reaches the configured count, RabbitMQ will stop delivering more messages until at least one of the outstanding deliveries is acknowledged.<br>Broker acknowledgements to publishers are called <b>publisher confirms</b>. The broker confirms messages (in confirm mode) by sending a basicAck to the publisher on the same channel. The basicAck method contains the delivery tag, which is a unique identifier (sequence number) for each message. When the broker is unable to handle messages successfully, the broker will send a basicNack.<br> 
	Consumer Acknowledgements and Publisher Confirms are based on TCP (socket).
	<center><img src="images\mq_ack.png" width="75%" height="75%"/></center>
	
	
    <h2>ToDo</h2>
	MassTransit (free): Event bus implementation that supports RabbitMQ (transport) and Prometheus (metrics)<br>
	NServiceBus (commercial): third-party library that can export metrics to Prometheus<br>
	Kafka

	<h2>References</h2>
 	<ul>
	  <li><a href="https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html">Getting Started with Java Message Service (JMS)</a></li>
	  <li><a href="https://de.wikipedia.org/wiki/Message_Queuing">Message Queuing</a></li>
	  <li><a href="https://www.eqengineered.com/insights/microservices-communication-frameworks-part-1">Microservices Communication Frameworks</a></li>
	  <li><a href="https://medium.com/startlovingyourself/need-of-messaging-queues-in-microservices-architecture-91de0db89120">Need of messaging queue in Microservices Architecture</a></li>
    </ul>
  </body>
</html>