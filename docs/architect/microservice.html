<!doctype html>
<html>
  <head>
    <title>Microservice Architecture</title>
    <link rel="stylesheet" href="../common.css">
  </head>
  <body>
    <h1>Microservice Architecture</h1>
	<p>Multiple autonomous microservices (each one owning its own data/db)</p>
	
    <h2>What are microservices?</h2>
	<p><a href="https://simple.wikipedia.org/wiki/Microservices">Microservices[1]</a> are designed to scale very well, consume fewer resources, and be loosely coupled.</p>
	
	<p><a href="https://microservices.io/">Microservices[2]</a> is an architectural style that structures an application as a collection of services that are:</p>
 	<ul>
	  <li>Independently deployable</li>
	  <li>Loosely coupled</li>
	  <li>Organized around business capabilities</li>
	  <li>Owned by a small team</li>
	</ul>
	<p>The microservice architecture enables an organization to deliver large, complex applications rapidly, frequently, reliably and sustainably.</p>
	
	<p><a href="https://learn.microsoft.com/en-us/azure/architecture/microservices/">Microservices[3]</a> are a popular architectural style for building applications that are resilient, highly scalable, independently deployable, and able to evolve quickly.</p>
	
    <h2>Microservice Architecture</h2>	
    <img src="images\microservice_architecture.png" width="100%" height="100%"/>
    <img src="images\microservice_lb.png" width="40%" height="40%"/>
	
	<h2>History</h2>
	<p>Here is a brief overview of some of the milestones in the history of microservices:</p>
 	<ul>
	  <li>Back in 2005, when Peter Rodgers, the architect of NetKernel and Father of Resource-Oriented Computing, was presenting at the Web Services Edge Conference, he is credited to have first introduced the term 'Micro Web Services', while making a point for REST services and putting forth the idea of 'Software as Micro-Web-Services'.</li>
	  <li>Since then, microservices have gained widespread adoption and popularity among many companies and organizations, such as Netflix, Amazon, Spotify, Twitter, and Google.</li>	  
	</ul>	

	<h2>Monolithic vs Microservices Architecture</h2>
    <table>
    <tr>
    <td><img src="images\serverless.png" width="100%" height="100%"/></td>
    <td><img src="images\scaling.png" width="100%" height="100%"/></td>
    </tr>
    </table>	
	
	<p>Suppose you go to the bakery to buy a cake. Unfortunately, the supplier has been unable to supply the ingredient to the bakery. Now, the bakery has been working to arrange an alternate supplier. However, the bakery still has other products available. So, the bakery is still up and running, while it is working to find a solution of how to begin cake production as soon as possible. But their absence does not affect the overall functioning of the bakery, except affecting a certain aspect or function of it. It would leave the customers a little disappointed, but while the other fare is still available, chances are the customer experience would not be all that negative either. This is possible because the bakery did not depend on a single supplier for everything and has divided itself into separate services. Due to this, <i>breakdown</i> in one service does not affect the overall functioning of all the other services. Also, a new service can be added without affecting the overall functioning of the application.</p>



	<h2>REST vs Message Broker</h2>
	<p>REST is based on a synchronous communication pattern, which means that the sender and the receiver have to be online at the same time and wait for each other. REST follows <b>stateless communication</b> (e.g. HTTP), which means that each request contains all the information necessary to process it, and no state is maintained on the server side. Transaction speed is fast.</p>
	<p>Message broker is based on an asynchronous communication pattern, which means that the sender and the receiver can be online at different times and do not have to wait for each other. Message broker follows <b>stateful communication</b> (e.g. FTP), which means that packets depend on previous communications. Stateful applications use sessions to preserve their states. Since the server knows the connection state, not every request needs authentication.</p>
	<p>In some cases, it may be beneficial to use both methods for different purposes or scenarios. For example:</p>
 	<ul>
	  <li>Use REST for simple CRUD operations or queries that require immediate responses or consistency guarantees.</li>
	  <li>Use Message Broker for complex business events or commands that can tolerate delays or eventual consistency.</li>
	  <li>Use REST for service discovery or health checks that need to be fast and lightweight.</li>
	  <li>Use Message Broker for notifications or alerts that need to be reliable and durable.</li>
	  <li>Use REST for strong consistency, such as banking transactions or e-commerce orders. </li>
	  <li>Use Message Broker for eventual consistency, such as social media updates or analytics reports.</li>
	</ul>		
	
	<h2>6Ô∏è Popular API Architecture Styles</h2>
	<center><img src="images\arch_styles.gif" width="50%" height="50%"/></center>	
	
	<h2>Netflix Tech Stack</h2>
	<center><img src="images\netflix.png" width="75%" height="75%"/></center>
	<center><img src="images\netflix_evo.png" width="75%" height="75%"/></center>
    <p>The evolution of the Netflix API (Netflix API Redesign) can be summarized in four main stages:</p>
    1. <b>Monolith</b>: The application was initially packaged and deployed as a monolith, such as a single Java WAR file or Rails app.<br>
    2. <b>Direct Access</b>: In this architecture, a client app could make requests directly to the microservices.<br>
    3. <b>Gateway Aggregation Layer</b>: As some use cases spanned multiple services, a gateway aggregation layer was introduced. This layer made it possible for the Netflix app to make requests to multiple APIs (like movie, production, talent) to render the frontend.<br>
    4. <b>Federated Gateway</b>: As the number of developers grew and domain complexity increased, developing the API aggregation layer became increasingly harder. To address this, Netflix introduced GraphQL federation, which allows for the setup of a single GraphQL gateway that fetches data from all other APIs.</p>
	
	<h2>References</h2>
 	<ul>	
	  <li><a href="https://www.cognixia.com/blog/what-are-microservices/">Cognixia - What are Microservices</a></li>	
	  <li><a href="https://www.youtube.com/watch?v=88_LUw1Wwe4">Top 5 techniques for building the worst microservice system ever</a></li>	
	  <li><a href="https://learn.particular.net/courses/distributed-systems-design-fundamentals-online">Distributed Systems Design Fundamentals</a></li>
	  <li><a href="https://www.youtube.com/watch?v=y8OnoxKotPQ">KRAZAM - Microservices</a></li>
	  <li><a href="https://vibratingmelon.com/2011/06/10/why-you-should-almost-never-rewrite-code-a-graphical-guide/">Why You Should (Almost) Never Rewrite Code</a></li>	  
	  <li><a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM">Mastering Chaos - A Netflix Guide to Microservices</a></li>
	  <li><a href="https://www.youtube.com/watch?v=Uu32ggF-DWg">Demystifying the Unusual Evolution of the Netflix API Architecture</a></li>	
	</ul>
  </body>
</html>