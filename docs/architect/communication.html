<!doctype html>
<html>
  <head>
    <title>Communication Patterns</title>
    <link rel="stylesheet" href="../common.css">
  </head>
  <body>
    <h1>Communication Patterns</h1>

	<h2>REST vs Message Broker</h2>
	<p>REST is based on a synchronous communication pattern, which means that the sender and the receiver have to be online at the same time and wait for each other. REST follows <b>stateless communication</b> (e.g. HTTP), which means that each request contains all the information necessary to process it, and no state is maintained on the server side. Transaction speed is fast.</p>
	<p>Message broker is based on an asynchronous communication pattern, which means that the sender and the receiver can be online at different times and do not have to wait for each other. Message broker follows <b>stateful communication</b> (e.g. FTP), which means that packets depend on previous communications. Stateful applications use sessions to preserve their states. Since the server knows the connection state, not every request needs authentication.</p>
	<p>In some cases, it may be beneficial to use both methods for different purposes or scenarios. For example:</p>
 	<ul>
	  <li>Use REST for simple CRUD operations or queries that require immediate responses or consistency guarantees.</li>
	  <li>Use Message Broker for complex business events or commands that can tolerate delays or eventual consistency.</li>
	  <li>Use REST for service discovery or health checks that need to be fast and lightweight.</li>
	  <li>Use Message Broker for notifications or alerts that need to be reliable and durable.</li>
	  <li>Use REST for strong consistency, such as banking transactions or e-commerce orders. </li>
	  <li>Use Message Broker for eventual consistency, such as social media updates or analytics reports.</li>
	</ul>
	<center><img src="images\sync_vs_async.png" width="75%" height="75%"/></center>
	
	<h2>Communication Protocols</h2>
    <table border="1"><thead>
      <tr>
        <th>Protocol</th>
        <th>Format</th>
        <th>Connection Lifecycle</th>
        <th>Transport Protocol</th>
        <th>Streaming Support</th>
      </tr></thead>
    <tbody>
      <tr>
        <td>REST</td>
        <td>JSON/XML</td>
        <td>1 connection per request-response </td>
        <td>HTTP/HTTPS over TCP</td>
        <td>No</td>
      </tr>
      <tr>
        <td>SOAP</td>
        <td>XML (Envelope-based)</td>
        <td>1 connection per request</td>
        <td>HTTP/HTTPS over TCP</td>
        <td>No</td>
      </tr>
      <tr>
        <td>GraphQL</td>
        <td>JSON</td>
        <td>1 connection per request-response;<br>persistent connection for subscriptions</td>
        <td>HTTP/HTTPS over TCP</td>
        <td>No</td>
      </tr>
      <tr>
        <td>Webhook</td>
        <td>JSON/XML</td>
        <td>1 HTTP request per event </td>
        <td>HTTP/HTTPS over TCP</td>
        <td>No</td>
      </tr>
      <tr>
        <td>gRPC</td>
        <td>Protocol Buffers</td>
        <td>Persistent</td>
        <td>HTTP/2 over TCP</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>WebSocket</td>
        <td>Text/Binary frames</td>
        <td>Persistent</td>
        <td>TCP-socket</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>MQTT/AMQP</td>
        <td>Binary messages</td>
        <td>Persistent</td>
        <td>TCP-socket</td>
        <td>Yes</td>
      </tr>
    </tbody></table>
	
	<h2>Popular API Architecture Styles</h2>
	<center><img src="images\arch_styles.gif" width="75%" height="75%"/></center>

  </body>
</html>