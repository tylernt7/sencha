<!doctype html>
<html>
  <head>
    <title>Property</title>
	<link rel="stylesheet" href="../../common.css">
  </head>
  <body>
    <h1>Property</h1>
	<b>Question:</b><br>
	What is the difference between .NET and C#?<br>
	<b>Answer:</b><br>
	.NET is a platform, while C# is a programming language.<br>		
	<br>
	<b>Question:</b><br>
	A. Write a simple class with a simple <i>double</i> property which can be read out but not set externally.<br>
	B. How else could you do it?<br> 
	C. Why did you choose your solution?<br>
	<b>Answer:</b><br>
	A.<br>
	<div class="code"><code><pre>public class SimpleClass
{
    private double _myProperty;

    public double MyProperty
    {
        get { return _myProperty; }
        private set { _myProperty = value; }
    }

    public SimpleClass(double value)
    {
        _myProperty = value;
    }
}<pre></code></div>
	B1. Using a read-only property with a backing field:
	<div class="code"><code><pre>
    ...
    public double MyProperty
    {
        get { return _myProperty; }
    }
    ...<pre></code></div>
	B2. Using an auto-implemented property with a private setter:	
	<div class="code"><code><pre>
    ...
    public double MyProperty { get; private set; }
    ...<pre></code></div>
	B3. Using a readonly modifier on the field, which prevents it from being modified after the constructor. This way, you don't need to define a property, and you can access the field directly:
	<div class="code"><code><pre>
    ...	
    private readonly double _myProperty;
    public double GetMyProperty()
    {
        return _myProperty;
    }
    ...<pre></code></div>	
	
	C.<br> 
	- I chose the A solution because it provides more flexibility. With a private setter, you can change the value of <b>MyProperty</b> from within the class if needed, which can be useful in certain scenarios.<br>
	- The B1 solution is more restrictive, as <b>MyProperty</b> can only be set in the constructor and can't be changed afterwards. However, both solutions effectively prevent <b>MyProperty</b> from being set from outside the class. The choice between these two solutions would depend on the specific requirements of your application.<br>
	- I chose the B1 solution because it follows the principle of encapsulation, which is one of the key concepts of object-oriented programming. Encapsulation means hiding the implementation details of a class from the outside world, and exposing only the relevant functionality through public interfaces. By using a property, I can control how the value of the field is accessed and modified, and I can also add validation, logic, or other behaviors if needed. A property also makes the code more readable and consistent, as it follows the common convention of using PascalCase for public members of a class.<br>
	- The B2 solution using an auto-implemented property with a private setter is also valid and more concise. However, it may not explicitly convey the read-only intention as clearly as the B3 solution with a method. The choice between these approaches often depends on coding conventions, project standards, and personal preferences.<br>
	- I chose the B3 solution with a private field and a getter method (<b>GetMyProperty()</b>) because it explicitly emphasizes that the property is read-only. This makes it clear that the value cannot be modified externally. Using a method for retrieval instead of a property can provide additional control over the naming conventions, especially if you want to convey that it's not just a simple property but a method call with a specific purpose.

  </body>
</html>