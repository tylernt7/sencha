<!doctype html>
<html>
  <head>
    <title>Welcome</title>
    <link rel="stylesheet" href="common.css">
  </head>
  <body>
    <h1>Programozói teszt (C#)</h1>
 
    <p><b>Question</b>: True/False</p>

<b>Answer</b>:<br>
You can define multiple custom networks in a single Docker Compose file<br>
<i>True. You can use the top-level networks key to define custom networks and the service-level networks key to specify what networks each service should join. For example, a Docker Compose file could define two custom networks: frontend and backend</i><br>

In cryptography PKI stands for Private Key Infrastructure<br>
<i>False. PKI stands for Public Key Infrastructure</i><br>

Businesses may prefer to keep their applications on on-premise infrastructure for security and compliance reasons.<br>
<i>True. They have more control over their data and applications, and can customize their security policies and practices according to their specific needs</i><br>
<i>They have to comply with certain regulations or standards that require them to store or process their data in a specific location or manner</i><br>
<i>They have concerns about the availability, reliability, or performance of cloud services, especially in case of network outages or disruptions</i><br>

RabbitMQ enables synchronous processing of messages between microservices.<br>
<i>False. RabbitMQ enables asynchronous processing of messages between microservices, meaning that it allows you to put a message in a queue without processing it immediately. This way, the message producer and consumer do not have to wait for each other or be available at the same time. Asynchronous processing can improve the scalability, reliability, and performance of microservices</i><br>

Storing binary data (e.g. images) as string can cause corruption or distortion of the data.<br>
<i>True</i><br>

SOAP UI can only test SOAP based web services, for other services (e.g. REST) Postman can be used<br>
<i>True</i><br>
	
    <p><b>Question</b>: How can you make the following code more extensible and maintainable without modifying its existing logic?</p>
	 <div class="code"><code><pre>
public interface Payment
{
    public enum Type { CreditCard, PayPal };
    public Type GetType();
} 
	 
private void ProcessPayments(List&lt;Payment> payments)
{
  foreach (Payment payment in payments)
  {
    switch (payment.GetType()) 
    {
      case CreditCard:
        ProcessCreditCard((CreditCard) payment);
        break;
      case PayPal:
        ProcessPayPal((PayPal) payment);
        break;
    }
  }
}</pre></code></div>
    <b>Answer</b>: Code can be improved with the <b>Open Closed Principle (SOLID)</b> (nyitott a bővítésre, zárt a módosításra). A class should be open for extension but closed for modification. In other words, add functionality by adding new code, not rewriting old code.
	
	 <div class="code"><code><pre>public interface Payment {
    void Process();
}

class CreditCard : Payment {
    public override void Process() {}
}

class PayPal : Payment {
    public override void Process() {}
}

private void ProcessPayments(List&lt;Payment> payments) {
    foreach (Payment payment in payments) {
        payment.Process();
    }
}</pre></code></div>	


    <p><b>Question</b>: Does this code compile? Will the code throw an exception during execution? What issues can you find?
	 <div class="code"><code><pre>public interface IEmailSender
{
  Task SendEmailAsync(string email, string subject, string message);
}

public class EmailSender : IEmailSender
{
  private readonly SmtpClient _client;

  public EmailSender(SmtpClient client)
  {
    _client = client;
  }
  
  public async Task SendEmailAsync(string email, string subject, string message)
  {
    var mailMessage = new MailMessage("noreply@example.com", email, subject, message);
    _client.SendMailAsync(mailMessage);
  }
}

public class Startup 
{
  public void ConfigureServices(IServiceCollection services)
  {
    services.Transient&lt;IEmailSender>(sp => new EmailSender(new SmtpClient("smtp.example.com")));     
  }
}

public class HomeController : Controller
{
  private final IEmailSender _emailSender;
  
  public HomeController(IEmailSender emailSender)
  {
    _emailSender = emailSender;
  }
}</pre></code></div>

    <b>Answer</b>: Correctly implemented <b>dependency injection</b> using the built-in IServiceCollection interface (Microsoft.Extensions.DependencyInjection)<div class="code"><code><pre>public interface IEmailSender
{
  Task SendEmailAsync(string email, string subject, string message);
}

public class EmailSender : IEmailSender
{
  private readonly SmtpClient _client;

  public EmailSender(SmtpClient client)
  {
    _client = client;
  }
  
  public async Task SendEmailAsync(string email, string subject, string message)
  {
    var mailMessage = new MailMessage("noreply@example.com", email, subject, message);
    // CS4017: Because this call is not awaited, execution of the current method continues before the call is completed. 
    // Consider applying the 'await' operator to the result of the call.
    <b>await</b> _client.SendMailAsync(mailMessage);
  }
}

public class Startup 
{

  // It configures the dependency injection services for an ASP.NET Core application. The lambda expression takes a parameter of type IServiceProvider, 
  // which is an interface for resolving dependencies. The AddTransient method registers the EmailSender class as a transient service for the IEmailSender interface, 
  // meaning that a new instance of EmailSender will be created every time it is requested by another service or controller.
  public void ConfigureServices(IServiceCollection services)
  {
    services.<b>AddTransient</b>&lt;IEmailSender>(sp => new EmailSender(new SmtpClient("smtp.example.com")));	
  }
}

public class HomeController : Controller
{
  private <b>readonly</b> IEmailSender _emailSender;
  
  public HomeController(IEmailSender emailSender)
  {
    _emailSender = emailSender;
  }
}</pre></code></div>
	
<b>Question</b>: What is base64 and what is it used for?<br>
<b>Answer</b>: Base64 is a binary-to-text encoding scheme that represents binary data in an ASCII string format. It is used for transferring binary data over media that are designed to deal with textual data, such as email or URLs. This ensures that the data remains intact and uncorrupted during transport<br>
<b>Question</b>: How does base64 encoding work?<br>
<b>Answer</b>: Base64 encoding works by dividing the input binary data into 6-bit blocks and mapping each block to a 64-character alphabet. The alphabet consists of A-Z, a-z, 0-9, + and /, with = as a padding character. The output string is formed by concatenating the encoded blocks. The output length is always a multiple of 4.<br>
<b>Question</b>: What are the advantages and disadvantages of base64 encoding?<br>
<b>Answer</b>: Some advantages of base64 encoding are:<br>
•  It can encode any binary data, regardless of its content or format.<br>
•  It can be safely transmitted over text-based protocols or channels that may alter or discard some binary values.<br>
•  It can be easily implemented and supported by many languages and libraries.<br>
Some disadvantages of base64 encoding are:<br>
•  It increases the size of the data by about 33%, which may affect the bandwidth and storage requirements.<br>
•  It is not secure or encrypted, and anyone can decode the data easily.<br>
•  It is not human-readable or meaningful, and it may be hard to debug or verify.<br>
<b>Question</b>: What are some common use cases of base64 encoding?<br>
<b>Answer</b>: Some common use cases of base64 encoding are:<br>
•  Embedding images or other binary data in HTML or CSS files, such as data URIs.<br>
•  Encoding email attachments or MIME parts, such as Base64 Content-Transfer-Encoding.<br>
•  Encoding cryptographic keys or tokens, such as JSON Web Tokens (JWT).<br>
•  Encoding binary data in URLs, such as Base64 URL Encoding.<br>

<b>Question</b>: How can you check if a string is base64 encoded or not?<br>
<b>Answer</b>: There is no definitive way to check if a string is base64 encoded or not, but there are some heuristics that can help. Some possible steps are:<br>
•  Check the length of the string. It should be a multiple of 4, or a multiple of 4 plus 1 or 2 if there is padding.<br>
•  Check the characters of the string. They should be from the base64 alphabet, which consists of A-Z, a-z, 0-9, + and /, with = as a padding character. There are also URL-safe variants that use - and _ instead of + and /.<br>
•  Check the padding of the string. There should be at most 2 padding characters at the end of the string, and they should be =.<br>
•  Try to decode the string using a base64 decoder. If it succeeds without errors, it is likely that the string is base64 encoded.<br>
	
    <p><b>Question</b>: Implement a method that returns the nth fibonacci number.<br>https://leetcode.com/problems/fibonacci-number/<br>
    <b>Answer</b>: Using recursive approach:
	 <div class="code"><code><pre>public int Fibonacci(int n)
{
  if (n &lt;= 0)
  {
    return -1;
  }
  else if (n == 1 || n == 2)
  {
    return 1;
  }
  else
  {
    return Fibonacci(n - 1) + Fibonacci(n - 2);
  }
}</pre></code></div>

    Or using iterative approach:
	 <div class="code"><code><pre>public static int Fibonacci(int n)
{
  if (n &lt;= 0)
  {
    return -1;
  }
  int a = 0; <i>// 0th fibonacci number</i>
  int b = 1; <i>// 1st fibonacci number</i>
  for (int i = 1; i &lt; n; i++)
  {
    int c = a + b;
    a = b;
    b = c;
  }
  return b;
}</pre></code></div>    

  </body>
</html>