<!doctype html>
<html>
  <head>
    <title>Welcome</title>
    <link rel="stylesheet" href="common.css">
  </head>
  <body>
    <h1>Interjú kérdések</h1>
	
    <h2>SQL</h2>
    <p><b>Kérdés: Mit ért tárolt eljárás alatt SQL-ben?</b><br>
    <b>Válasz</b>: A tárolt eljárások olyan SQL parancsok halmaza, amelyeket az adatbázisban tárolnak és újra felhasználhatóak. Egy tárolt eljárás bemeneti és kimeneti paramétereket is fogadhat, így több kliens is használhatja ugyanazt az eljárást a hálózaton keresztül különböző bemeneti adatokkal.<br> 
    <b>Innopay példa</b>: sp_delete_payment_requests</p>
    
    <p><b>Kérdés: Milyen előnyei és hátrányai vannak az adatbázis tábla tartomány szerinti particionálásának (PARTITION BY RANGE)?</b><br>
    <b>Válasz</b>: Ebben a technikában az adatok egy értéktartomány alapján vannak felosztva.<br>
    - Előnye: Lehetővé teszi azon adatok hatékony levágását, amelyekre nincs szükség egy adott lekérdezéshez. Ez jelentős teljesítményjavuláshoz vezethet nagy adatkészletek kezelésekor.<br>
    - Hátránya: Megkövetelheti a partíciós séma és funkció manuális karbantartását, például a határértékek megváltoztatását, a partíciók összevonását vagy felosztását, hogy alkalmazkodni tudjon az adatok vagy üzleti követelmények változásaihoz.<br>
    <b>Innopay példa</b>: CREATE TABLE data.payment_requests_partitioned (...) PARTITION BY RANGE (transaction_status)</p>
    
    <p><b>Kérdés: Hogyan biztosítja az SQL szabvány az elosztott tranzakciók atomiságát és konzisztenciáját?</b><br>
    <b>Válasz</b>: Az SQL szabvány az elosztott tranzakciók atomiságát és konzisztenciáját a COMMIT és a ROLLBACK utasításokkal biztosítja. A COMMIT utasítás véglegesíti a tranzakció által végrehajtott módosításokat, és lezárja a tranzakciót. A ROLLBACK utasítás visszaállítja az adatbázist a tranzakció kezdete előtti állapotra, és lezárja a tranzakciót. Mindkét utasítás hatására a tranzakcióban érintett adatok feloldódnak, és más tranzakciók számára elérhetővé válnak.<br>
    <b>Innopay példa</b>:
    <pre>void SavePartner() {
  try {
  	SavePartner();
  	transaction.Commit();
  } catch {
  	transaction.Rollback();
  }
}</pre></p>
        
    <p><b>Kérdés: Mi a különbség a LEFT JOIN és az INNER JOIN között?</b><br>
    <b>Válasz</b>: A LEFT JOIN és az INNER JOIN közötti különbség az, hogy a LEFT JOIN visszaadja az összes sort a bal oldali táblából, függetlenül attól, hogy van-e egyezés a jobb oldali táblában, míg az INNER JOIN csak akkor ad vissza sorokat, ha van egyezés mindkét táblában.	
		
	<h2>Clean code</h2>
    
    <p><b>Kérdés: Sorolja fel a SOLID alapelveket</b><br>
    <b>Válasz</b>:<br>
    - Single Responsibility Principle (Egyetlen felelősség elv)<br>
    - Open Closed Principle (Nyílt zárt elv)<br>
    - Liskov Substitution Principle (Liskov helyettesítési elv)<br>
    - Interface Segregation Principle (Interfész szétválasztási elv)<br>
    - Dependency Inversion Principle (Függőség megfordítási elv)</p>
            
	<h2>Mikroszolgáltatások</h2>
    
    <p><b>Kérdés: Milyen szinkron és aszinkron technológiákat ismer mikroszolgáltatások kommunikációja esetén?</b><br>
    <b>Válasz</b>:<br>
    - Szinkron kommunikációs módszerek: REST, SOAP, WebSocket és gRPC<br>
    - Aszinkron kommunikációs módszerek: RabbitMQ, ActiveMQ és Apache Kafka<br>
    <b>Innopay példa</b>: REST, SOAP és RabbitMQ<br>
    
    <p><b>Kérdés: Hogyan állíthat be és használhat környezeti változókat a Docker Compose alkalmazásban?</b><br>
    <b>Válasz</b>:<br>
    - Egy .env fájl létrehozása a docker-compose.yml fájl mellett<br>
    - Az environment attribútum használata a Docker Compose fájlban<br>
    - Az env_file attribútum használata a Docker Compose fájlban<br>
    - Környezeti változók használata a shellben<br>
    <b>Innopay példa</b>: IQR, PKI</p>
    
    <p><b>Kérdés: Mi az OpenID Connect 1.0 és miben különbözik az OAuth 2.0-tól?</b><br>
    <b>Válasz</b>: Az OpenID Connect 1.0 egy egyszerű azonosítási réteg az OAuth 2.0 protokoll felett. Lehetővé teszi az ügyfelek számára, hogy ellenőrizzék a végfelhasználók identitását azon alapulva, hogy hogyan hitelesítette őket egy engedélyezési szerver, valamint hogy interoperábilis és REST-szerű módon szerezzék be a végfelhasználók profilinformációit. Az OAuth 2.0 nem foglalkozik a felhasználók hitelesítésével, csak az erőforrásokhoz való hozzáférés engedélyezésével. Az OpenID Connect tehát kiegészíti az OAuth 2.0-t egy hitelesítési réteggel, amely lehetővé teszi a felhasználók egyszeri bejelentkezését (SSO) az OAuth-kompatibilis alkalmazások között egy biztonsági token segítségével, amelyet identitás tokennek (JSON Web Token, JWT) neveznek.

	<h2>.NET</h2>
	
    <p><b>Kérdés: Dapper: Mi a különbség a Dapper és az EF Core teljesítménye között? Melyik ORM javasolt egy nagy forgalmú real-time pénzügyi alkalmazásban?</b></p>
    <b>Válasz</b>: A Dapper és az EF Core teljesítménye között általában a Dapper a gyorsabb, mert nyers SQL lekérdezéseket használ és kevesebb felesleges műveletet végez. Az EF Core lassabb, mint a Dapper, mert sokkal több funkcióval rendelkezik, ami több erőforrást igényel. Azonban az EF Core bizonyos esetekben gyorsabb lehet, mint a Dapper, mert rendelkezik gyorsítótárazással és más teljesítményoptimalizáló technikákkal<br>
    - A pénzügyi alkalmazásoknak nagyon fontos a gyorsaság és a pontosság, ezért a Dapper előnye, hogy közvetlenül a SQL szerverrel kommunikál és minimálisra csökkenti az adatbázis és az objektumok közötti átalakítást.<br>
    - A pénzügyi alkalmazásoknak általában szükségük van komplex lekérdezésekre vagy tárolt eljárásokra, amelyeket az EF Core nem támogat vagy nehezen kezel. A Dapper lehetővé teszi, hogy teljes mértékben irányítsuk a SQL utasításokat és könnyen megoldjuk az EF Core által nem támogatott eseteket<br>

    <p><b>Kérdés: FluentAssertions: Hogyan írná át az Assert.AreEqual(3, result.Count)-t FluentAssertions-al?</b></p>
    <b>Válasz</b>: result.Count.Should().Be(3);

    <p><b>Kérdés: EntityFrameworkCore.InMemory: Hogyan lehet szimulálni tranzakciókat, amelyeket az InMemory adatbázis nem támogat Unit tesztek során?</b></p>
    <b>Válasz</b>: Az InMemory adatbázis egy olyan adatbázis, amelyet a memóriában tárolnak, nem pedig a lemezen. Nem támogatja a tranzakciókat, azaz nem lehet visszavonni vagy visszaállítani az adatokat. Ez problémát jelenthet a unit tesztelés során, mert nem lehet ellenőrizni, hogy a kód hogyan viselkedik a tranzakciókkal. Erre több módszer is létezik:<br>
    - Használjunk egy másik adatbázis-szolgáltatót, amely támogatja a tranzakciókat, például az SQLite-t<br>
    - Használjunk egy mock vagy stub objektumot, amely utánozza az adatbázis-kezelő rendszer viselkedését

    <p><b>Kérdés: Flutter:  Hogyan lehet terjeszthető buildet készíteni Flutterel Androidra és iOS-ra?</b></p>
    <b>Válasz</b>:<br>	
    - Android: 'flutter build appbundle --flavor dev'<br>
    - iOS: 'flutter build ios --flavor dev'

    <p><b>Kérdés: AutoMapper: Hogyan lehet AutoMapper-t kézzel helyettesíteni?</b></p>
    <b>Válasz</b>: Saját metódusokat írunk, amelyek átveszik az egyik objektumot paraméterként, létrehoznak és visszaadnak egy másik objektumot, amelynek a tulajdonságai megfelelnek az első objektum tulajdonságainak.

    <p><b>Kérdés: Hangfire/Autofac: Hogyan lehet használni az Autofac-et a Hangfire háttérfeladatokhoz, úgy hogy a feladatok megkapják a szükséges függőségeket (függőségi befecskendezést)?</b></p>
    <b>Válasz</b>: Az Autofac-et úgy lehet használni a Hangfire háttérfeladatokhoz, hogy egy AutofacJobActivator osztályt hozunk létre, amely az Autofac konténert használja a feladatokhoz szükséges osztálypéldányok létrehozásához. Ezután be kell állítanunk a JobActivator.Current tulajdonságot erre az osztályra, hogy a Hangfire ezt használja feladat aktivátorként.

    <p><b>Kérdés: FluentValidation: Hogyan lehet használni a FluentValidation-t, hogy automatikusan validálja a modell osztályokat és a DTO-kat?</b></p>
    <b>Válasz</b>: A FluentValidation-t úgy lehet használni, hogy telepítjük a FluentValidation.AspNetCore csomagot, és regisztráljuk a validátor osztályokat a Startup.cs fájlban. Ezután használhatjuk az [ApiController] és [Validate] attribútumokat, hogy automatikusan validálja a modell osztályokat és a DTO-kat.
	
    <p><b>Kérdés: Swagger: Hogyan lehet megadni reguláris kifejezéseket Swagger-ben/OpenAPI-ban?</b></p>
    <div class="code"><code><pre>- name: reconCycleId
  in: query
  required: true
  schema:
    type: string
    <b>pattern: '^[0-2][0-9]$'</b>
    maxLength: 2
    minLength: 2</pre></code></div>
	
    <p><b>Kérdés</b>: Mi a különbség az AddSingleton és az AddTransient metódusok között az ASP.NET Core függőségi injekcióban?<br>
    <b>Válasz</b>:<br>
    - AddSingleton: A szolgáltatások az első kéréskor jönnek létre (az objektumok minden kérésnél ugyanazok)<br>
    - AddTransient: A szolgáltatások minden alkalommal létrejönnek, amikor kérik őket (az objektumok mindig mások)<br>
    - AddScoped: A szolgáltatások webes kliens kérésenként/kapcsolatonként egyszer jönnek létre (az objektumok ugyanazok egy adott kérésnél, de minden új kérésnél eltérőek)<br>
    <b>Innopay példa</b>: Persistence\DependencyInjection.cs (AddSingleton, AddTransient)</p>

	<h2>Angular</h2>
    
    <p><b>Kérdés: Milyen konfigurációs fájllal és hogyan oldható meg a többnyelvűség Angularban? Mi az i18n?</b></p>
	<b>Válasz</b>: assets/i18n alatt en.json és hu.json fájl. Html-ben csak a kulcsot adjuk meg ami itt van a json-on belül és a hozzá tartozó értéket kiszedjük a választott nyelvhez.

    <p><b>Kérdés: Mi a különbség az Angularban és a Dotben használt promise között?</b></p>
	<b>Válasz</b>:<br>- Az Angularban a promise a JavaScript beépített Promise objektumát használja. A C#-ban a promise a Task osztályt használja.<br>
	- Az Angularban a promise-t az $q szolgáltatás segítségével lehet létrehozni és kezelni. A C#-ban a promise-t az async és await kulcsszavak segítségével lehet létrehozni és kezelni.<br>
	- Az Angularban a promise-t az $applyAsync metódus segítségével lehet integrálni az Angular digest ciklusába, amely automatikusan frissíti a nézetet, ha a promise állapota megváltozik. A C#-ban a promise-t nem kell integrálni semmilyen ciklusba, mert az async és await kulcsszavak automatikusan szinkronizálják a kódot.<br>

	<h2>Tesztelés</h2>
    
    <p><b>Kérdés: Milyen Black-box és White-box technikákat ismersz?</b><br>
	<p><b>Kérdés: Milyen munkaterhelési modelleket (workload models) ismersz a teljesítménytesztben?</b><br>
	
	<h2>DevOps</h2>
    
    <p><b>Kérdés: Mi az a Terraform és mire használható?</b></p>		
	<b>Válasz</b>: A TerraForm egy nyílt forráskódú eszköz, amely segítségével infrastruktúrát írhatunk le kód formájában, és ezt a kódot felhasználva létrehozhatjuk, frissíthetjük vagy törölhetjük az infrastruktúrát. Egy egyszerű és ember által olvasható konfigurációs nyelvet alkalmaz (HashiCorp Configuration Language, <b>HCL</b>), amely könnyen tanulható és használható. Előnyei közé tartozik a platformfüggetlenség, a moduláris és újrafelhasználható kód, a változások előzetes megtekintése és visszaállítása, valamint a különböző környezetek kezelése.

	
  </body>
</html>