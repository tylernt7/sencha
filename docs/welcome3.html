<!doctype html>
<html>
  <head>
    <title>Welcome</title>
    <link rel="stylesheet" href="common.css">
  </head>
  <body>
    <h1>Programoz√≥i teszt (C#)</h1>

    <p><b>Question</b>: What is the difference between IEnumerable and IQueryable in C#?</p>

<b>Answer</b>: IEnumerable and IQueryable are both interfaces that define a collection of data that can be iterated over using a foreach loop. However, they have some important differences:<br>
- IEnumerable is defined in the System.Collections namespace and represents an in-memory collection of data. It supports deferred execution, meaning that the data is not fetched or processed until it is enumerated. It also supports LINQ methods that use lambda expressions as parameters.<br>
- IQueryable is defined in the System.Linq namespace and represents a queryable collection of data that can be executed on a remote data source, such as a database or a web service. It supports deferred execution, meaning that the query is not executed until it is enumerated. It also supports LINQ methods that use expression trees as parameters, which can be translated into SQL or other query languages by an IQueryable provider.<br>
The main difference between IEnumerable and IQueryable is that <b>IEnumerable</b> performs the query operations on the <b>client</b> side, while <b>IQueryable</b> performs them on the <b>server</b> side. This means that IEnumerable will fetch all the data from the data source and then apply the filters or transformations on the client side, which can be inefficient and consume more memory. On the other hand, IQueryable will translate the query operations into an expression tree and send it to the data source, which will execute the query and return only the required data to the client side, which can be more efficient and consume less memory.<br>
Therefore, it is recommended to use IEnumerable when working with in-memory collections or small data sets, and use IQueryable when working with remote data sources or large data sets.
	
    <p><b>Question</b>: What does the code below do and how can it be improved?</p>
	 <div class="code"><code><pre>private void ProcessPayments(List&lt;IPayment> payments)
{
  foreach (Payment payment in payments)
  {
    switch (payment.GetType()) 
    {
      case CreditCard:
        PayByCreditCard((CreditCard) payment);
        break;
      case PayPal:
        PayWithPayPal((PayPal) payment);
        break;
    }
  }
}</pre></code></div>
    <b>Answer</b>: Code can be improved with the <b>Open Closed Principle (SOLID)</b>. A class should be open for extension but closed for modification. In other words, add functionality by adding new code, not rewriting old code.
	
	 <div class="code"><code><pre>interface Payment {
    void Pay();
}

class CreditCard : Payment {
    public override void Pay() {
        Console.WriteLine("CreditCard.Pay()");
    }
}

class PayPal : Payment {
    public override void Pay() {
        Console.WriteLine("PayPal.Pay()");
    }
}

private void ProcessPayments(List&lt;Payment> payments) {
    foreach (Payment payment in payments) {
        payment.Pay();
    }
}</pre></code></div>	


    <p><b>Question</b>: Does this code compile? Will the code throw an exception during execution? What issues can you find?
	 <div class="code"><code><pre>public interface IEmailSender
{
  Task SendEmailAsync(string email, string subject, string message);
}

public class EmailSender : IEmailSender
{
  private readonly SmtpClient _client;

  public EmailSender(SmtpClient client)
  {
    _client = client;
  }
  
  public async Task SendEmailAsync(string email, string subject, string message)
  {
    var mailMessage = new MailMessage("noreply@example.com", email, subject, message);
    _client.SendMailAsync(mailMessage);
  }
}

public class Startup 
{
  public void ConfigureServices(IServiceCollection services)
  {
    services.Transient&lt;IEmailSender>(sp => new EmailSender(new SmtpClient("smtp.example.com")));     
  }
}

public class HomeController : Controller
{
  private final IEmailSender _emailSender;
  
  public HomeController(IEmailSender emailSender)
  {
    _emailSender = emailSender;
  }
}</pre></code></div>

    <b>Answer</b>: Correctly implemented <b>dependency injection</b> using the built-in IServiceCollection interface<div class="code"><code><pre>public interface IEmailSender
{
  Task SendEmailAsync(string email, string subject, string message);
}

public class EmailSender : IEmailSender
{
  private readonly SmtpClient _client;

  public EmailSender(SmtpClient client)
  {
    _client = client;
  }
  
  public async Task SendEmailAsync(string email, string subject, string message)
  {
    var mailMessage = new MailMessage("noreply@example.com", email, subject, message);
    <b>await</b> _client.SendMailAsync(mailMessage);
  }
}

public class Startup 
{
  public void ConfigureServices(IServiceCollection services)
  {
    services.<b>AddTransient</b>&lt;IEmailSender>(sp => new EmailSender(new SmtpClient("smtp.example.com")));
	
  }
}

public class HomeController : Controller
{
  private <b>readonly</b> IEmailSender _emailSender;
  
  public HomeController(IEmailSender emailSender)
  {
    _emailSender = emailSender;
  }
}</pre></code></div>
	
    <p><b>Question</b>: How do you encode a base64 string in C#?<br>
    <b>Answer</b>: 

<div class="code"><code><pre>var plainText = "InnoPay";
var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);
var base64EncodedText = <b>System.Convert.ToBase64String</b>(plainTextBytes);
Console.WriteLine(base64EncodedText); <i>// Output: SW5ub1BheQ==</i></pre></code></div>	
	
    <p><b>Question</b>: Implement a method that returns the nth fibonacci number.<br>
    <b>Answer</b>: Using recursive approach:
	 <div class="code"><code><pre>public int Fibonacci(int n)
{
  if (n &lt;= 0)
  {
    return -1;
  }
  else if (n == 1 || n == 2)
  {
    return 1;
  }
  else
  {
    return Fibonacci(n - 1) + Fibonacci(n - 2);
  }
}</pre></code></div>

    Or using iterative approach:
	 <div class="code"><code><pre>public static int Fibonacci(int n)
{
  if (n &lt;= 0)
  {
    return -1;
  }
  int a = 0; <i>// 0th fibonacci number</i>
  int b = 1; <i>// 1st fibonacci number</i>
  for (int i = 1; i &lt; n; i++)
  {
    int c = a + b;
    a = b;
    b = c;
  }
  return b;
}</pre></code></div>    

  </body>
</html>